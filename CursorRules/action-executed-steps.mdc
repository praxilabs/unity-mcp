---
description: These Rules are conditions of usage and best practicies for the action executed steps.
alwaysApply: false
---
# Action-Executed Step Nodes

Action-executed step nodes require user interaction before proceeding to the next step. These nodes inherit from `ActionExecuted` base class and wait for specific user actions.

## Base Class

### ActionExecuted
- **File**: [ActionExecuted.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted.cs)
- **Purpose**: Base class for all user interaction nodes
- **Behavior**: Waits for user input, then calls `Execute(GameObject)` with the interacted object

## Node Types

### ClickStep
- **File**: [ClickStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/ClickStep.cs)
- **NodeTint**: `#B43F3F` (Red)
- **Menu Path**: "Click/Click Object"
- **Purpose**: Handle clicking on specific objects in the scene
- **Parameters**:
  - `_targetName` (RegistryItem): Target object to click
  - `clickableObject` (GameObject): Resolved clickable object
- **Behavior**:
  - Flashes the target object to indicate it's clickable
  - Waits for user to click the correct object
  - Proceeds when the clicked object matches the target
- **Visual Feedback**: Uses `ToolsFlashManager` to flash the target object

### UIClickStep
- **File**: [UIClickStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/UIClickStep.cs)
- **Purpose**: Handle clicking on UI elements
- **Parameters**:
  - `_targetName` (RegistryItem): Target UI element to click
- **Behavior**: Similar to ClickStep but specifically for UI elements

### RotateKnobStep
- **File**: [RotateKnobStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/RotateKnobStep.cs)
- **Purpose**: Handle knob rotation interactions
- **Parameters**:
  - `_targetName` (RegistryItem): Target knob to rotate
  - `targetRotation` (float): Target rotation value
  - `tolerance` (float): Acceptable rotation tolerance
- **Behavior**:
  - Waits for user to rotate the knob to the target value
  - Proceeds when rotation is within tolerance
- **Use Cases**: Volume controls, parameter adjustments, calibration

### AttachStep
- **File**: [AttachStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/AttachStep.cs)
- **Purpose**: Handle object attachment interactions
- **Parameters**:
  - `_sourceName` (RegistryItem): Object to be attached
  - `_targetName` (RegistryItem): Object to attach to
- **Behavior**:
  - Waits for user to attach source object to target
  - Proceeds when attachment is completed
- **Use Cases**: Connecting wires, placing components, assembling parts

### DetachStep
- **File**: [DetachStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/DetachStep.cs)
- **Purpose**: Handle object detachment interactions
- **Parameters**:
  - `_targetName` (RegistryItem): Object to detach
- **Behavior**:
  - Waits for user to detach the specified object
  - Proceeds when detachment is completed
- **Use Cases**: Removing components, disconnecting wires

### ExploreStep
- **File**: [ExploreStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/ExploreStep.cs)
- **Purpose**: Handle exploration interactions
- **Parameters**:
  - `_targetName` (RegistryItem): Object to explore
- **Behavior**:
  - Waits for user to explore/interact with the target
  - Proceeds when exploration is completed
- **Use Cases**: Examining objects, reading labels, discovering features

### ORStep
- **File**: [ORStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/ORStep.cs)
- **Purpose**: Logical OR operation for multiple conditions
- **Parameters**:
  - Multiple input conditions
  - Single output when any condition is met
- **Behavior**:
  - Waits for any of the connected conditions to be satisfied
  - Proceeds when the first condition is met
- **Use Cases**: Multiple valid interaction paths, alternative solutions

## Common Patterns

### Visual Feedback Pattern
Most action-executed steps provide visual feedback:
```csharp
// Flash the target object
ToolsFlashManager.Instance.StartFlashing(clickableObject);

// Stop flashing when step is ignored
ToolsFlashManager.Instance.StopFlashing(clickableObject);
```

### Object Resolution Pattern
All action-executed steps resolve objects from the registry:
```csharp
public override void ResolveObjects()
{
    base.ResolveObjects();
    clickableObject = ExperimentItemsContainer.Instance.Resolve(_targetParent, targetName);
}
```

### Step Completion Pattern
Steps signal completion to the runner:
```csharp
public override void Exit()
{
    IgnoreStep(); // Clean up visual feedback
    XnodeStepsRunner.Instance.StepIsDone(); // Signal completion
}
```

## Best Practices

1. **Visual Feedback**: Always provide clear visual indicators for what the user should interact with
2. **Error Handling**: Implement proper cleanup in `IgnoreStep()` method
3. **Object Resolution**: Use the registry system for consistent object references
4. **User Guidance**: Combine with `HintStep` nodes to provide clear instructions
5. **Timing**: Use `DelayStep` before action steps to ensure UI is ready

## Integration with Other Nodes

- **HintStep**: Provide instructions before action steps
- **DelayStep**: Ensure proper timing before user interactions
- **FunctionCallStep**: Execute setup/cleanup functions
- **ProgressMapManualNextStep**: Allow user control over progression

## File References

- Action-executed base: [ActionExecuted.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted.cs)
- All action-executed nodes: [Assets/Scripts/System/xNode/Steps/ActionExecuted/](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/)
- Tools flash manager: [Assets/Scripts/System/ToolsFlashManager.cs](mdc:Assets/Scripts/System/ToolsFlashManager.cs)
   └─ Return to ActionExecutedStep - Retry
3. Success path continues to next phase
```
# Action-Executed Step Nodes

Action-executed step nodes require user interaction before proceeding to the next step. These nodes inherit from `ActionExecuted` base class and wait for specific user actions.

## Base Class

### ActionExecuted
- **File**: [ActionExecuted.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted.cs)
- **Purpose**: Base class for all user interaction nodes
- **Behavior**: Waits for user input, then calls `Execute(GameObject)` with the interacted object

## Node Types

### ClickStep
- **File**: [ClickStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/ClickStep.cs)
- **NodeTint**: `#B43F3F` (Red)
- **Menu Path**: "Click/Click Object"
- **Purpose**: Handle clicking on specific objects in the scene
- **Parameters**:
  - `_targetName` (RegistryItem): Target object to click
  - `clickableObject` (GameObject): Resolved clickable object
- **Behavior**:
  - Flashes the target object to indicate it's clickable
  - Waits for user to click the correct object
  - Proceeds when the clicked object matches the target
- **Visual Feedback**: Uses `ToolsFlashManager` to flash the target object

### UIClickStep
- **File**: [UIClickStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/UIClickStep.cs)
- **Purpose**: Handle clicking on UI elements
- **Parameters**:
  - `_targetName` (RegistryItem): Target UI element to click
- **Behavior**: Similar to ClickStep but specifically for UI elements

### RotateKnobStep
- **File**: [RotateKnobStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/RotateKnobStep.cs)
- **Purpose**: Handle knob rotation interactions
- **Parameters**:
  - `_targetName` (RegistryItem): Target knob to rotate
  - `targetRotation` (float): Target rotation value
  - `tolerance` (float): Acceptable rotation tolerance
- **Behavior**:
  - Waits for user to rotate the knob to the target value
  - Proceeds when rotation is within tolerance
- **Use Cases**: Volume controls, parameter adjustments, calibration

### AttachStep
- **File**: [AttachStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/AttachStep.cs)
- **Purpose**: Handle object attachment interactions
- **Parameters**:
  - `_sourceName` (RegistryItem): Object to be attached
  - `_targetName` (RegistryItem): Object to attach to
- **Behavior**:
  - Waits for user to attach source object to target
  - Proceeds when attachment is completed
- **Use Cases**: Connecting wires, placing components, assembling parts

### DetachStep
- **File**: [DetachStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/DetachStep.cs)
- **Purpose**: Handle object detachment interactions
- **Parameters**:
  - `_targetName` (RegistryItem): Object to detach
- **Behavior**:
  - Waits for user to detach the specified object
  - Proceeds when detachment is completed
- **Use Cases**: Removing components, disconnecting wires

### ExploreStep
- **File**: [ExploreStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/ExploreStep.cs)
- **Purpose**: Handle exploration interactions
- **Parameters**:
  - `_targetName` (RegistryItem): Object to explore
- **Behavior**:
  - Waits for user to explore/interact with the target
  - Proceeds when exploration is completed
- **Use Cases**: Examining objects, reading labels, discovering features

### ORStep
- **File**: [ORStep.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/ORStep.cs)
- **Purpose**: Logical OR operation for multiple conditions
- **Parameters**:
  - Multiple input conditions
  - Single output when any condition is met
- **Behavior**:
  - Waits for any of the connected conditions to be satisfied
  - Proceeds when the first condition is met
- **Use Cases**: Multiple valid interaction paths, alternative solutions

## Common Patterns

### Visual Feedback Pattern
Most action-executed steps provide visual feedback:
```csharp
// Flash the target object
ToolsFlashManager.Instance.StartFlashing(clickableObject);

// Stop flashing when step is ignored
ToolsFlashManager.Instance.StopFlashing(clickableObject);
```

### Object Resolution Pattern
All action-executed steps resolve objects from the registry:
```csharp
public override void ResolveObjects()
{
    base.ResolveObjects();
    clickableObject = ExperimentItemsContainer.Instance.Resolve(_targetParent, targetName);
}
```

### Step Completion Pattern
Steps signal completion to the runner:
```csharp
public override void Exit()
{
    IgnoreStep(); // Clean up visual feedback
    XnodeStepsRunner.Instance.StepIsDone(); // Signal completion
}
```

## Best Practices

1. **Visual Feedback**: Always provide clear visual indicators for what the user should interact with
2. **Error Handling**: Implement proper cleanup in `IgnoreStep()` method
3. **Object Resolution**: Use the registry system for consistent object references
4. **User Guidance**: Combine with `HintStep` nodes to provide clear instructions
5. **Timing**: Use `DelayStep` before action steps to ensure UI is ready

## Integration with Other Nodes

- **HintStep**: Provide instructions before action steps
- **DelayStep**: Ensure proper timing before user interactions
- **FunctionCallStep**: Execute setup/cleanup functions
- **ProgressMapManualNextStep**: Allow user control over progression

## File References

- Action-executed base: [ActionExecuted.cs](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted.cs)
- All action-executed nodes: [Assets/Scripts/System/xNode/Steps/ActionExecuted/](mdc:Assets/Scripts/System/xNode/Steps/ActionExecuted/)
- Tools flash manager: [Assets/Scripts/System/ToolsFlashManager.cs](mdc:Assets/Scripts/System/ToolsFlashManager.cs)
   └─ Return to ActionExecutedStep - Retry
3. Success path continues to next phase
```