---
alwaysApply: true
---

# Node Positioning Strategy

## **HYBRID POSITIONING PRINCIPLE**

**Use horizontal flow as the foundation, but group nodes vertically by logic to create appealing, organized layouts.**

**Why Hybrid?**
- **Horizontal flow**: Natural reading pattern, logical sequence
- **Vertical grouping**: Prevents infinite horizontal lines, creates visual appeal
- **Logical organization**: Groups related operations together
- **User experience**: Avoids both infinite lines and giant blocks

## **SPACING STANDARDS**
- **Horizontal**: 450px between sequential nodes in same logical group
- **Vertical**: 300px between parallel routes or logical levels
- **Stage Separation**: 600px between major logical stages
- **Start Position**: (0, 0) for first node

## **FLEXIBLE POSITIONING RULE**
**This is NOT a rigid grid system. You can position nodes flexibly like bricks in a wall.**

**When to use flexible positioning:**
- When a row is full (4-5 nodes) and the next row has only 2-3 nodes
- When logical grouping requires uneven distribution
- When visual balance needs improvement

**Flexible positioning examples:**
```bash
# Row 1: Full row (5 nodes)
(0,0) → (450,0) → (900,0) → (1350,0) → (1800,0)

# Row 2: Only 2 nodes - position them for visual balance
(225,300) → (675,300)  # Centered, not forced to start at (0,300)

# Row 3: 3 nodes - distribute evenly
(0,600) → (450,600) → (900,600)  # Can start at (0,600) if it makes sense
```

**Key principle**: Prioritize visual appeal and logical flow over rigid grid alignment.

## **FORBIDDEN PATTERNS**
- **NEVER create infinite horizontal lines** (more than 4-5 nodes in single row)
- **NEVER create infinite vertical stacks** (more than 3-4 nodes in single column)
- **NEVER create giant blocks** (dense clusters without breathing room)
- **NEVER ignore logical grouping** - always group related operations
- **NEVER ignore user experience** - prioritize visual appeal and readability

## **REQUIRED PATTERNS**
- **ALWAYS use horizontal flow as foundation** for logical sequence
- **ALWAYS group nodes vertically by logic** to prevent infinite lines
- **ALWAYS create appealing visual layouts** with proper spacing
- **ALWAYS consider user navigation experience** and visual appeal
- **ALWAYS balance horizontal flow with vertical grouping**

## **POSITIONING ALGORITHM**

### **Step 1: Analyze Graph Complexity**
```
1. Count total nodes
2. Identify logical phases (setup, operations, validation, completion)
3. Determine parallel operations
4. Assess user interaction requirements
```

### **Step 2: Select Strategy Based on Node Count**
```
IF nodes <= 5:
    Strategy = "Single Row (Horizontal)"
    Max per row = 5 (exception for simple graphs only)
    Layout = (0,0) → (450,0) → (900,0) → (1350,0) → (1800,0)

ELIF nodes <= 8:
    Strategy = "2-3 Rows (Hybrid)"
    Max per row = 4
    Rows = 2-3

ELIF nodes <= 15:
    Strategy = "3-4 Rows (Hybrid)"
    Max per row = 4
    Rows = 3-4

ELSE:
    Strategy = "4+ Rows (Hybrid)"
    Max per row = 4
    Rows = 4+
```

### **Step 3: Apply Logical Grouping**
```
FOR each logical phase:
    1. Group related operations together
    2. Assign to horizontal row
    3. Maintain 450px horizontal spacing
    4. Use 300px vertical separation between phases
```

### **Step 4: Apply Flexible Positioning**
```
IF row has fewer nodes than previous row:
    1. Center nodes for visual balance
    2. Distribute evenly within available space
    3. Prioritize visual appeal over rigid alignment
```

### **Step 5: Validate Layout**
```
CHECK:
- Clear visual separation between phases
- Logical flow from left to right, top to bottom
- Professional, organized appearance
- Visual balance and appeal
```

---

## 🛠️ **IMPLEMENTATION EXAMPLES**

### **Simple Graph (≤5 nodes)**
```bash
# Single horizontal row
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 0      # Start
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 0    # Step 1
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 0    # Step 2
mcp_unityMCP_create_xnode_node --position_x 1350 --position_y 0   # Step 3
mcp_unityMCP_create_xnode_node --position_x 1800 --position_y 0   # Complete
```

### **Medium Graph (6-8 nodes)**
```bash
# 2-3 Rows with logical grouping
# Row 1: Setup Phase
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 0      # Start
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 0    # Setup
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 0    # Initialize

# Row 2: Main Operations
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 300    # Operation A
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 300  # Operation B
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 300  # Operation C

# Row 3: Completion
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 600    # Finalize
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 600  # End
```

### **Complex Graph (9+ nodes)**
```bash
# 4+ Rows with logical grouping
# Row 1: Setup Phase
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 0      # Start
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 0    # Setup
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 0    # Initialize

# Row 2: Main Operations
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 300    # Operation A
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 300  # Operation B
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 300  # Operation C

# Row 3: Validation
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 600    # Check A
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 600  # Check B
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 600  # Check C

# Row 4: Completion
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 900    # Finalize
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 900  # Cleanup
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 900  # End
```

---

## **KEY PRINCIPLES**

1. **Visual Appeal First**: Prioritize visual balance and logical flow over rigid positioning rules
2. **Hybrid Strategy**: Balance horizontal flow with vertical grouping
3. **Flexible Positioning**: Use brick-like positioning for visual balance when rows are uneven
4. **Logical Grouping**: Organize nodes by function and logical phases
5. **Professional Appearance**: Maintain clean, organized, and visually appealing layouts

**Priority Hierarchy**: Visual appeal and logical flow > Flexible positioning > Rigid grid alignment

**Remember**: The goal is optimal user experience through balanced positioning that combines horizontal flow with logical vertical grouping.
