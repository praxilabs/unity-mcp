---
alwaysApply: true
---

# Unity MCP Bridge - Essential Rules & Category Reference

## üö® CRITICAL RULES ‚ö†Ô∏è

### **COLLIDER MANAGEMENT RULE**
**"Enable collider" = `ToggleColliderStep` (NOT `GameObjectSetActiveStep`)**
- ‚ùå **Wrong**: `GameObjectSetActiveStep` for colliders
- ‚úÖ **Correct**: `ToggleColliderStep` for collider management

### **VALIDATION LOOP RULE**
**After ANY correction, you MUST re-validate and continue the fix‚Üívalidate cycle until 100% error-free.**
- Never stop at first fix
- Always complete the full validation cycle
- Use `list_graph_nodes` after each correction

## üéØ QUICK DECISION TREE

### Need to show/hide objects?
‚Üí **Tools** category ‚Üí [GameObjectSetActiveStep](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc)

### Need to enable/disable colliders?
‚Üí **Tools** category ‚Üí [ToggleColliderStep](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc) ‚≠ê **CRITICAL RULE**

### Need user interaction in any order?
‚Üí **Control Flow** category ‚Üí [CompositeStep pattern](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc)

### Need sequential execution?
‚Üí **Chain: Node1.exit ‚Üí Node2.entry**

### Need function calls?
‚Üí **Function Call** category ‚Üí [FunctionCallStep](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc)

## üìÇ STEP NODE CATEGORIES OVERVIEW

### üîó Attach-Detach
**Purpose**: Handle object attachment and detachment operations
**Use Cases**: Equipment assembly, component connections, interactive object manipulation
**Key Nodes**: AttachStep, DetachStep
**When to Use**: When objects need to be physically connected or disconnected
**Reference**: [Attach-Detach Nodes](mdc:.cursor/rules/MCP/GraphLogic/Attach-DetachNodes.mdc)

### üñ±Ô∏è Click
**Purpose**: Handle user clicking interactions
**Use Cases**: User interface interactions, object selection, interactive object manipulation
**Key Nodes**: ClickStep, RotateKnobStep, ExploreStep
**When to Use**: When user needs to interact with objects via clicking, rotating, or exploring
**Reference**: [Click Nodes](mdc:.cursor/rules/MCP/GraphLogic/ClickNodes.mdc)

### üîÑ Control Flow
**Purpose**: Manage execution flow and branching logic
**Use Cases**: Decision making, parallel execution, state management
**Key Nodes**: CompositeStep, IfStatementStep, SwitchStep, SwitchEnumStep
**When to Use**: When you need conditional logic, parallel execution, or state machines
**Reference**: [Control Flow Nodes](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc)

### üì∑ Camera
**Purpose**: Control camera positioning and focus
**Use Cases**: Guided attention, view management, detailed object examination
**Key Nodes**: FocusOnToolStep, ReturnCameraStep
**When to Use**: When you need to guide user attention or provide detailed views
**Reference**: [Camera Nodes](mdc:.cursor/rules/MCP/GraphLogic/CameraNodes.mdc)

### ‚öôÔ∏è Function Call
**Purpose**: Execute methods on GameObjects
**Use Cases**: Component method execution, system interactions
**Key Nodes**: FunctionCallStep
**When to Use**: When you need to call specific methods on objects (NOT for visibility)
**Reference**: [Function Call Nodes](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc)

### üîÅ Loops
**Purpose**: Handle iterative operations
**Use Cases**: Repeated actions, data collection, iterative processes
**Key Nodes**: ForLoopStep, WhileLoopStep
**When to Use**: When you need to repeat actions a fixed number of times or until a condition is met
**Reference**: [Loop Nodes](mdc:.cursor/rules/MCP/GraphLogic/LoopNodes.mdc)

### üõ†Ô∏è Tools
**Purpose**: Object manipulation and visibility control
**Use Cases**: Object state management, interaction control, visibility, collider management
**Key Nodes**: GameObjectSetActiveStep, ToggleColliderStep
**When to Use**: 
- **GameObjectSetActiveStep**: Show/hide objects
- **ToggleColliderStep**: Enable/disable colliders ‚≠ê **CRITICAL RULE**
**Reference**: [Tool Nodes](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc)

### üñ•Ô∏è UI
**Purpose**: User interface and messaging
**Use Cases**: User guidance, feedback, timing controls, educational content
**Key Nodes**: SideMessageStep, HintStep, TimerStep
**When to Use**: When you need to communicate with users or provide timing controls
**Reference**: [UI Nodes](mdc:.cursor/rules/MCP/GraphLogic/UINodes.mdc)

### ‚ö° Utility
**Purpose**: System utility operations
**Use Cases**: System control, timing, modular execution
**Key Nodes**: FreezeLabStep, DelayStep, SubGraphStep
**When to Use**: When you need system-wide control, timing, or modular execution
**Reference**: [Utility Nodes](mdc:.cursor/rules/MCP/GraphLogic/UtilityNodes.mdc)

### üéØ NewEvents
**Purpose**: Event-driven interactions
**Use Cases**: Reactive programming, event handling
**Key Nodes**: Event-based step nodes
**When to Use**: When you need reactive programming or event-driven logic
**Reference**: [NewEvents Nodes](mdc:.cursor/rules/MCP/GraphLogic/NewEventsNodes.mdc)

### üìä Table
**Purpose**: Data table operations
**Use Cases**: Data management, table interactions
**Key Nodes**: Table-related step nodes
**When to Use**: When you need to manage data in table format
**Reference**: [Table Nodes](mdc:.cursor/rules/MCP/GraphLogic/TableNodes.mdc)

### üó∫Ô∏è Progress Map
**Purpose**: Progress tracking and navigation
**Use Cases**: Experiment progress, navigation control
**Key Nodes**: Progress-related step nodes
**When to Use**: When you need to track experiment progress or control navigation
**Reference**: [Progress Map Nodes](mdc:.cursor/rules/MCP/GraphLogic/ProgressMapNodes.mdc)

### üé¨ Animation Step
**Purpose**: Animation control and playback
**Use Cases**: Object animations, visual effects
**Key Nodes**: AnimationStep
**When to Use**: When you need to animate objects or create visual effects
**Reference**: [Misc Nodes](mdc:.cursor/rules/MCP/GraphLogic/MiscNodes.mdc)

## üìê NODE POSITIONING

### Spacing Rules
- **Horizontal**: 400 units between sequential nodes
- **Vertical**: 300 units between parallel routes
- **Start**: (100, 100) for first node

### Connection Patterns
```
Sequential: Node1.exit ‚Üí Node2.entry ‚Üí Node3.entry
Parallel: CompositeStep.routes ‚Üí [Node1, Node2, Node3] ‚Üí CompositeStep.entry
```

## üö® CRITICAL CONNECTION RULES ‚ö†Ô∏è

### **MANDATORY NODE CONNECTION REQUIREMENTS**

1. **First Step Node Rule**: 
   - **NEVER connect TO the entry port of a first step node**
   - **MUST connect FROM the exit port of a first step node**
   - First step nodes can only have outgoing connections

2. **End Node Rule**: 
   - **NEVER connect FROM the exit port of an end node**
   - **MUST connect TO the entry port of an end node**
   - End nodes can only have incoming connections

3. **Middle Node Rule**: 
   - **ALL middle nodes MUST have BOTH incoming AND outgoing connections**
   - **Incoming**: From previous node's exit port
   - **Outgoing**: To next node's entry port
   - **Violation**: If a middle node lacks either connection, your logic is 100% incorrect

4. **Sequential Execution Rule**: 
   - **When disabling/enabling multiple colliders sequentially**: Execute ONE at a time
   - **NOT parallel execution**: Our graphs are NOT designed for parallel execution
   - **Key Difference**: Parallel execution ‚â† Parallel order
   - **Correct Pattern**: Node1.exit ‚Üí Node2.entry ‚Üí Node3.entry ‚Üí Node4.entry
   - **Wrong Pattern**: Multiple nodes ‚Üí Single target (creates parallel execution)

### **CONNECTION VALIDATION CHECKLIST**
- ‚úÖ First step: Only outgoing connections (exit port)
- ‚úÖ Middle nodes: Both incoming (entry) and outgoing (exit) connections
- ‚úÖ End nodes: Only incoming connections (entry port)
- ‚úÖ Sequential operations: One node at a time, not parallel
- ‚úÖ No floating nodes: Every node must be part of the execution flow

**VIOLATION OF THESE RULES WILL RESULT IN BROKEN EXPERIMENTS**

## üîó ADDITIONAL REFERENCES

- [MCP Tools Reference](mdc:.cursor/rules/MCP/mcp-tools-reference.mdc) - Complete tool reference
- [Step Nodes Reference](mdc:.cursor/rules/MCP/step-nodes-reference.mdc) - Core step nodes overview

**Remember**: When in doubt, always verify in the codebase first!


**Remember**: When in doubt, always verify in the codebase first!


# Unity MCP Bridge - Essential Rules & Category Reference

## üéØ QUICK DECISION TREE

### Need to show/hide objects?
‚Üí **Tools** category ‚Üí [GameObjectSetActiveStep](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc)

### Need user interaction in any order?
‚Üí **Control Flow** category ‚Üí [CompositeStep pattern](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc)

### Need sequential execution?
‚Üí **Chain: Node1.exit ‚Üí Node2.entry**

### Need function calls?
‚Üí **Function Call** category ‚Üí [FunctionCallStep](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc)

## üìÇ STEP NODE CATEGORIES OVERVIEW

### üîó Attach-Detach
**Purpose**: Handle object attachment and detachment operations
**Use Cases**: Equipment assembly, component connections, interactive object manipulation
**Key Nodes**: AttachStep, DetachStep
**When to Use**: When objects need to be physically connected or disconnected
**Reference**: [Attach-Detach Nodes](mdc:.cursor/rules/MCP/GraphLogic/Attach-DetachNodes.mdc)

### üñ±Ô∏è Click
**Purpose**: Handle user clicking interactions
**Use Cases**: User interface interactions, object selection, interactive object manipulation
**Key Nodes**: ClickStep, RotateKnobStep, ExploreStep
**When to Use**: When user needs to interact with objects via clicking, rotating, or exploring
**Reference**: [Click Nodes](mdc:.cursor/rules/MCP/GraphLogic/ClickNodes.mdc)

### üîÑ Control Flow
**Purpose**: Manage execution flow and branching logic
**Use Cases**: Decision making, parallel execution, state management
**Key Nodes**: CompositeStep, IfStatementStep, SwitchStep, SwitchEnumStep
**When to Use**: When you need conditional logic, parallel execution, or state machines
**Reference**: [Control Flow Nodes](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc)

### üì∑ Camera
**Purpose**: Control camera positioning and focus
**Use Cases**: Guided attention, view management, detailed object examination
**Key Nodes**: FocusOnToolStep, ReturnCameraStep
**When to Use**: When you need to guide user attention or provide detailed views
**Reference**: [Camera Nodes](mdc:.cursor/rules/MCP/GraphLogic/CameraNodes.mdc)

### ‚öôÔ∏è Function Call
**Purpose**: Execute methods on GameObjects
**Use Cases**: Component method execution, system interactions
**Key Nodes**: FunctionCallStep
**When to Use**: When you need to call specific methods on objects (NOT for visibility)
**Reference**: [Function Call Nodes](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc)

### üîÅ Loops
**Purpose**: Handle iterative operations
**Use Cases**: Repeated actions, data collection, iterative processes
**Key Nodes**: ForLoopStep, WhileLoopStep
**When to Use**: When you need to repeat actions a fixed number of times or until a condition is met
**Reference**: [Loop Nodes](mdc:.cursor/rules/MCP/GraphLogic/LoopNodes.mdc)

### üõ†Ô∏è Tools
**Purpose**: Object manipulation and visibility control
**Use Cases**: Object state management, interaction control, visibility
**Key Nodes**: GameObjectSetActiveStep, ToggleColliderStep
**When to Use**: When you need to show/hide objects or control interactions
**Reference**: [Tool Nodes](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc)

### üñ•Ô∏è UI
**Purpose**: User interface and messaging
**Use Cases**: User guidance, feedback, timing controls, educational content
**Key Nodes**: SideMessageStep, HintStep, TimerStep
**When to Use**: When you need to communicate with users or provide timing controls
**Reference**: [UI Nodes](mdc:.cursor/rules/MCP/GraphLogic/UINodes.mdc)

### ‚ö° Utility
**Purpose**: System utility operations
**Use Cases**: System control, timing, modular execution
**Key Nodes**: FreezeLabStep, DelayStep, SubGraphStep
**When to Use**: When you need system-wide control, timing, or modular execution
**Reference**: [Utility Nodes](mdc:.cursor/rules/MCP/GraphLogic/UtilityNodes.mdc)

### üéØ NewEvents
**Purpose**: Event-driven interactions
**Use Cases**: Reactive programming, event handling
**Key Nodes**: Event-based step nodes
**When to Use**: When you need reactive programming or event-driven logic
**Reference**: [NewEvents Nodes](mdc:.cursor/rules/MCP/GraphLogic/NewEventsNodes.mdc)

### üìä Table
**Purpose**: Data table operations
**Use Cases**: Data management, table interactions
**Key Nodes**: Table-related step nodes
**When to Use**: When you need to manage data in table format
**Reference**: [Table Nodes](mdc:.cursor/rules/MCP/GraphLogic/TableNodes.mdc)

### üó∫Ô∏è Progress Map
**Purpose**: Progress tracking and navigation
**Use Cases**: Experiment progress, navigation control
**Key Nodes**: Progress-related step nodes
**When to Use**: When you need to track experiment progress or control navigation
**Reference**: [Progress Map Nodes](mdc:.cursor/rules/MCP/GraphLogic/ProgressMapNodes.mdc)

### üé¨ Animation Step
**Purpose**: Animation control and playback
**Use Cases**: Object animations, visual effects
**Key Nodes**: AnimationStep
**When to Use**: When you need to animate objects or create visual effects
**Reference**: [Misc Nodes](mdc:.cursor/rules/MCP/GraphLogic/MiscNodes.mdc)

## üìê NODE POSITIONING

### Spacing Rules
- **Horizontal**: 400 units between sequential nodes
- **Vertical**: 300 units between parallel routes
- **Start**: (100, 100) for first node

### Connection Patterns
```
Sequential: Node1.exit ‚Üí Node2.entry ‚Üí Node3.entry
Parallel: CompositeStep.routes ‚Üí [Node1, Node2, Node3] ‚Üí CompositeStep.entry
```

## üö® CRITICAL CONNECTION RULES ‚ö†Ô∏è

### **MANDATORY NODE CONNECTION REQUIREMENTS**

1. **First Step Node Rule**: 
   - **NEVER connect TO the entry port of a first step node**
   - **MUST connect FROM the exit port of a first step node**
   - First step nodes can only have outgoing connections

2. **End Node Rule**: 
   - **NEVER connect FROM the exit port of an end node**
   - **MUST connect TO the entry port of an end node**
   - End nodes can only have incoming connections

3. **Middle Node Rule**: 
   - **ALL middle nodes MUST have BOTH incoming AND outgoing connections**
   - **Incoming**: From previous node's exit port
   - **Outgoing**: To next node's entry port
   - **Violation**: If a middle node lacks either connection, your logic is 100% incorrect

4. **Sequential Execution Rule**: 
   - **When disabling/enabling multiple colliders sequentially**: Execute ONE at a time
   - **NOT parallel execution**: Our graphs are NOT designed for parallel execution
   - **Key Difference**: Parallel execution ‚â† Parallel order
   - **Correct Pattern**: Node1.exit ‚Üí Node2.entry ‚Üí Node3.entry ‚Üí Node4.entry
   - **Wrong Pattern**: Multiple nodes ‚Üí Single target (creates parallel execution)

### **CONNECTION VALIDATION CHECKLIST**
- ‚úÖ First step: Only outgoing connections (exit port)
- ‚úÖ Middle nodes: Both incoming (entry) and outgoing (exit) connections
- ‚úÖ End nodes: Only incoming connections (entry port)
- ‚úÖ Sequential operations: One node at a time, not parallel
- ‚úÖ No floating nodes: Every node must be part of the execution flow

**VIOLATION OF THESE RULES WILL RESULT IN BROKEN EXPERIMENTS**

## üîó ADDITIONAL REFERENCES

- [MCP Tools Reference](mdc:.cursor/rules/MCP/mcp-tools-reference.mdc) - Complete tool reference
- [Step Nodes Reference](mdc:.cursor/rules/MCP/step-nodes-reference.mdc) - Core step nodes overview

**Remember**: When in doubt, always verify in the codebase first!


**Remember**: When in doubt, always verify in the codebase first!