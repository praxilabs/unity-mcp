---
alwaysApply: true
---

## üéØ **CRITICAL STAGE MANAGEMENT RULE** ‚≠ê **MANDATORY MULTI-STAGE HANDLING**

### **üö® MULTI-STAGE EXPERIMENT PRINCIPLE** ‚ö†Ô∏è **ABSOLUTELY MANDATORY**
**When a user requests multiple stages, each stage is a COMPLETELY SEPARATE StepsGraph with NO direct connections between them.**

#### **Stage Independence Rules:**
- **‚úÖ Each stage = Separate StepsGraph asset** in `Assets/Testing/Graphs/`
- **‚úÖ NO cross-stage node connections** within the same graph
- **‚úÖ Stage transitions ONLY via GoToStageStep** node
- **‚úÖ Each graph handles ONE stage completely**

#### **Multi-Stage Architecture:**
```bash
# ‚úÖ CORRECT: Separate graphs for each stage
Assets/Testing/Graphs/
‚îú‚îÄ‚îÄ ChemistryLab_VitaminCAnalysis_Stage1_StepGraph.asset
‚îú‚îÄ‚îÄ ChemistryLab_VitaminCAnalysis_Stage2_StepGraph.asset
‚îî‚îÄ‚îÄ ChemistryLab_VitaminCAnalysis_Stage3_StepGraph.asset

# ‚ùå WRONG: Single graph trying to handle multiple stages
Assets/Testing/Graphs/
‚îî‚îÄ‚îÄ ChemistryLab_VitaminCAnalysis_AllStages_StepGraph.asset  # FORBIDDEN
```

#### **Stage Transition Pattern:**
```bash
# ‚úÖ CORRECT: Use GoToStageStep for stage changes
Stage1_Graph: FinalNode ‚Üí GoToStageStep(Stage2) ‚Üí End
Stage2_Graph: Start ‚Üí Stage2Content ‚Üí End
```

---

## üé≠ **CRITICAL SCENARIO PATTERN RULE** ‚≠ê **MANDATORY SCENARIO HANDLING**

### **üö® SCENARIO SELECTION PATTERN** ‚ö†Ô∏è **ABSOLUTELY MANDATORY**
**ALL scenario-based experiments MUST follow this EXACT pattern for user choice handling:**

#### **MANDATORY SCENARIO PATTERN:**
```bash
1. GameObjectSetActiveStep(ChoicesCanvasUI) ‚Üí Enable choice UI
2. ClickUIStep(ConfirmScenarioButton) ‚Üí User clicks to confirm
3. FunctionCallStep(ChoicesUIScript.isScenarioA) ‚Üí Check user choice
4. IfStatementStep ‚Üí Route to correct scenario
   ‚îú‚îÄ‚îÄ True: Execute Scenario 1
   ‚îî‚îÄ‚îÄ False: Execute Scenario 2
```

#### **Scenario Pattern Implementation:**
```bash
# ‚úÖ CORRECT: Standard scenario pattern
GameObjectSetActiveStep(ChoicesCanvasUI) 
    ‚Üì
ClickUIStep(ConfirmScenarioButton)
    ‚Üì
FunctionCallStep(ChoicesUIScript.isScenarioA)
    ‚Üì
IfStatementStep
    ‚îú‚îÄ‚îÄ True ‚Üí Scenario1_SubGraph
    ‚îî‚îÄ‚îÄ False ‚Üí Scenario2_SubGraph
```

#### **SubGraph Usage for Scenarios:**
```bash
# ‚úÖ CORRECT: Use SubGraphStep for complex scenarios
IfStatementStep
    ‚îú‚îÄ‚îÄ True ‚Üí SubGraphStep(Scenario1_Graph)
    ‚îî‚îÄ‚îÄ False ‚Üí SubGraphStep(Scenario2_Graph)
```

---

## üéØ **CRITICAL POSITIONING & STAGING RULES** ‚≠ê **MANDATORY NODE POSITIONING**

### **üö® PRIMARY POSITIONING PRINCIPLE** ‚ö†Ô∏è **ABSOLUTELY MANDATORY**
**ALWAYS default to left-right (horizontal) flow unless there is a COMPELLING reason for vertical positioning.**

### **üìê MANDATORY SPACING STANDARDS** ‚ö†Ô∏è
- **Horizontal**: 450px between sequential nodes (left-right flow) - **PRIMARY**
- **Vertical**: 300px between parallel routes or levels - **SECONDARY**
- **Level Separation**: 600px between major logic groups
- **Start Position**: (0, 0) for first node

### **üö´ FORBIDDEN POSITIONING PATTERNS** ‚ö†Ô∏è
- ‚ùå **NEVER stack nodes on top of each other** (same X position)
- ‚ùå **NEVER force vertical flow for complex experiments** (6+ nodes)
- ‚ùå **NEVER use vertical as default** - requires explicit justification
- ‚ùå **NEVER create rigid vertical matrices** for complex logic

### **‚úÖ MANDATORY POSITIONING STRATEGY** ‚ö†Ô∏è
**For ANY experiment with 6+ nodes or parallel operations:**
```bash
# ‚úÖ CORRECT: Left-right horizontal flow (DEFAULT)
mcp_unityMCP_create_xnode_node --position_x 0 --position_y 0      # Start
mcp_unityMCP_create_xnode_node --position_x 450 --position_y 0    # Step 1
mcp_unityMCP_create_xnode_node --position_x 900 --position_y 0    # Step 2
mcp_unityMCP_create_xnode_node --position_x 1350 --position_y 0   # Step 3
mcp_unityMCP_create_xnode_node --position_x 1800 --position_y 0   # Complete
```

**For complex multi-route experiments:**
```bash
# ‚úÖ CORRECT: Level-based horizontal organization
Level 1: Start (0, 0) ‚Üí Setup (450, 0) ‚Üí Branch (900, 0)
Level 2: Route A (0, 300) ‚Üí Route B (450, 300) ‚Üí Route C (900, 300)
Level 3: Completion (1350, 300) ‚Üí End (1800, 300)
```

### **üéØ POSITIONING DECISION MATRIX** ‚ö†Ô∏è **MANDATORY**
| Graph Type | Node Count | **Required Strategy** |
|---|---|----|
| Simple Linear | 3-5 nodes | **Left-Right (DEFAULT)** |
| Equipment Setup | 4-8 nodes | **Left-Right (DEFAULT)** |
| Interactive Lab | 6+ nodes | **Left-Right (MANDATORY)** |
| Complex Experiment | 8+ nodes | **Left-Right (MANDATORY)** |
| Multi-Route | Any count | **Left-Right (MANDATORY)** |

---

## üé≠ **MANDATORY NODE STAGING RULES** ‚≠ê **READABILITY ENFORCEMENT**

### **üö® STAGING REQUIREMENT** ‚ö†Ô∏è **ABSOLUTELY MANDATORY**
**ALWAYS stage nodes in logical groups with clear visual separation for better readability.**

### **üìê STAGING SPACING STANDARDS** ‚ö†Ô∏è
- **Stage Separation**: 600px between major logical stages
- **Stage Grouping**: Group related nodes within 300px vertical range
- **Visual Hierarchy**: Use Y positioning to show logical relationships
- **Clear Boundaries**: Each stage should have distinct visual separation

### **‚úÖ MANDATORY STAGING STRATEGY** ‚ö†Ô∏è
**For experiments with multiple logical stages:**
```bash
# ‚úÖ CORRECT: Staged horizontal flow with logical grouping
Stage 1 - Setup: (0, 0) ‚Üí (450, 0) ‚Üí (900, 0)
Stage 2 - Interaction: (1350, 0) ‚Üí (1800, 0) ‚Üí (2250, 0)
Stage 3 - Validation: (2700, 0) ‚Üí (3150, 0) ‚Üí (3600, 0)
Stage 4 - Completion: (4050, 0) ‚Üí (4500, 0) ‚Üí (4950, 0)
```

**For parallel operations within stages:**
```bash
# ‚úÖ CORRECT: Stage-based parallel organization
Stage 1: Setup (0, 0) ‚Üí Branch (450, 0)
Stage 2: Route A (0, 300) ‚Üí Route B (450, 300) ‚Üí Merge (900, 300)
Stage 3: Validation (1350, 300) ‚Üí Complete (1800, 300)
```

### **üéØ STAGING DECISION MATRIX** ‚ö†Ô∏è **MANDATORY**
| Graph Complexity | **Required Staging** |
|---|----|
| Simple (3-5 nodes) | **Single Stage** (0, 0) to (1800, 0) |
| Medium (6-10 nodes) | **Two Stages** with 600px separation |
| Complex (11-15 nodes) | **Three Stages** with clear boundaries |
| Advanced (16+ nodes) | **Four+ Stages** with logical grouping |

### **üö´ FORBIDDEN STAGING PATTERNS** ‚ö†Ô∏è
- ‚ùå **NEVER create unorganized node clusters** without logical grouping
- ‚ùå **NEVER place all nodes in single horizontal line** for complex experiments
- ‚ùå **NEVER ignore logical stage boundaries** for readability
- ‚ùå **NEVER create dense node arrangements** without visual breathing room

---

## üìù **GRAPH NAMING RULE** ‚≠ê **MANDATORY DESCRIPTIVE NAMING**

**ALWAYS create graphs with descriptive, meaningful names that explain the graph's purpose and content.**

#### **Naming Convention Structure**
```
[ExperimentType]_[SpecificPurpose]_[GraphType]
```

#### **Naming Examples by Experiment Type**
- **Physics**: `PhysicsLab_Mechanics_StepGraph`, `PhysicsLab_Electricity_StepGraph`
- **Chemistry**: `ChemistryLab_Titration_StepGraph`, `ChemistryLab_Reactions_StepGraph`
- **Biology**: `BiologyLab_Microscopy_StepGraph`, `BiologyLab_Dissection_StepGraph`
- **Interactive**: `InteractiveLab_EquipmentSetup_StepGraph`, `InteractiveLab_DataCollection_StepGraph`

#### **Naming Guidelines**
1. **üéØ Be Specific**: Include exact experiment type and purpose
2. **üìã Include Phase**: If multi-phase, include phase number/name
3. **üîß Indicate Type**: Always include `StepGraph` suffix
4. **üìÅ Use Underscores**: Separate words with underscores
5. **üé® Be Descriptive**: Name should immediately tell you what the graph does
6. **üîç Avoid Generic Names**: Never use "NewStepsGraph", "Graph1", "Experiment", "Test"

---

## üéØ **EXPERIMENT TYPE DECISION RULE** ‚≠ê **CRITICAL DISTINCTION**

### **Random/Demo Graph Protocol (OPTIONAL assets):**
```bash
# 1. Create ExperimentData (optional but recommended)
mcp_unityMCP_create_scriptable_object --scriptable_object_type "ExperimentData" --asset_name "[Type]_RandomDemo_ExperimentData" --folder "Assets/Testing/"

# 2. Create ItemsRegistry (optional but recommended)  
mcp_unityMCP_create_scriptable_object --scriptable_object_type "ExperimentItemsRegistry" --asset_name "[Type]_RandomDemo_ItemsRegistry" --folder "Assets/Testing/"

# 3. Create StepsGraph (required)
mcp_unityMCP_create_scriptable_object --scriptable_object_type "StepsGraph" --asset_name "[Type]_RandomDemo_StepGraph" --folder "Assets/Testing/Graphs/"
```

### **Full Experiment Protocol (MANDATORY assets):**
```bash
# 1. Create ExperimentData (MANDATORY)
mcp_unityMCP_create_scriptable_object --scriptable_object_type "ExperimentData" --asset_name "[ExperimentType]_[Purpose]_ExperimentData" --folder "Assets/Testing/"

# 2. Create ItemsRegistry (MANDATORY)
mcp_unityMCP_create_scriptable_object --scriptable_object_type "ExperimentItemsRegistry" --asset_name "[ExperimentType]_[Purpose]_ItemsRegistry" --folder "Assets/Testing/"

# 3. Create StepsGraph (MANDATORY)
mcp_unityMCP_create_scriptable_object --scriptable_object_type "StepsGraph" --asset_name "[ExperimentType]_[Purpose]_StepGraph" --folder "Assets/Testing/Graphs/"
```

---

## üîß **CRITICAL TECHNICAL RULES** ‚ö†Ô∏è

### **RegistryItem Parameter Format** ‚≠ê **MANDATORY EXACT SYNTAX**
**ALWAYS use this EXACT format for RegistryItem parameters:**
```csharp
{"prefabName": "ParentName", "childName": "ChildName"}
```
**NEVER use:** `{prefabName: "Tools"}` or `{"prefabName: Tools"}` or any malformed syntax

### **ScriptableObject Class Names** ‚≠ê **MANDATORY EXACT NAMES**
**ALWAYS use these EXACT class names:**
- `"ExperimentItemsRegistry"` (NOT `"RegistryItemData"`)
- `"ExperimentData"` (NOT `"ExperimentDataSO"`)
- `"StepsGraph"`

### **Validation Loop Rule** ‚≠ê **MANDATORY**
**After ANY correction, you MUST re-validate and continue the fix‚Üívalidate cycle until 100% error-free.**
- Never stop at first fix
- Always complete the full validation cycle
- Use `list_graph_nodes` after each correction

---

## üß† **MANDATORY PRE-NODE CREATION RULE** ‚≠ê **ABSOLUTELY CRITICAL**

### **üö® GRAPH LOGIC PATTERN ANALYSIS** ‚ö†Ô∏è **REQUIRED BEFORE ANY NODE CREATION**
**BEFORE generating ANY node, you MUST analyze the graph logic patterns and common mistakes for the node types you plan to use.**

#### **‚úÖ MANDATORY PRE-CREATION CHECKLIST** ‚ö†Ô∏è
1. **‚úÖ Read relevant GraphLogic rule files** for your node types
2. **‚úÖ Study established patterns** and best practices
3. **‚úÖ Identify common mistakes** and failure modes
4. **‚úÖ Understand critical connection requirements** and validation rules
5. **‚úÖ Only THEN create nodes** with proper implementation

#### **üîç REQUIRED GRAPH LOGIC ANALYSIS** ‚ö†Ô∏è
**For ANY node creation, you MUST consult these rule files:**

- **Attach-Detach Operations**: [Attach-DetachNodes](mdc:.cursor/rules/MCP/GraphLogic/Attach-DetachNodes.mdc)
- **Click Interactions**: [ClickNodes](mdc:.cursor/rules/MCP/GraphLogic/ClickNodes.mdc)
- **Control Flow**: [ControlFlowNodes](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc) ‚≠ê **CRITICAL**
- **Camera Operations**: [CameraNodes](mdc:.cursor/rules/MCP/GraphLogic/CameraNodes.mdc)
- **Function Calls**: [FunctionCallNodes](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc)
- **Loops**: [LoopNodes](mdc:.cursor/rules/MCP/GraphLogic/LoopNodes.mdc)
- **Tool Operations**: [ToolNodes](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc) ‚≠ê **CRITICAL**
- **UI Interactions**: [UINodes](mdc:.cursor/rules/MCP/GraphLogic/UINodes.mdc)
- **Utility Operations**: [UtilityNodes](mdc:.cursor/rules/MCP/GraphLogic/UtilityNodes.mdc)
- **Event Systems**: [NewEventsNodes](mdc:.cursor/rules/MCP/GraphLogic/NewEventsNodes.mdc)
- **Data Tables**: [TableNodes](mdc:.cursor/rules/MCP/GraphLogic/TableNodes.mdc)
- **Progress Management**: [ProgressMapNodes](mdc:.cursor/rules/MCP/GraphLogic/ProgressMapNodes.mdc)
- **Misc Operations**: [MiscNodes](mdc:.cursor/rules/MCP/GraphLogic/MiscNodes.mdc)

#### **üö® CRITICAL PATTERN REQUIREMENTS** ‚ö†Ô∏è
**Each node type has specific patterns you MUST follow:**

- **Control Flow**: Mandatory connection requirements, parallel execution patterns
- **Tool Operations**: Sequential collider operation rules, critical safety patterns
- **Attach-Detach**: Equipment assembly patterns, component connection rules
- **Click Operations**: Interactive response patterns, user interaction flows
- **Function Calls**: Method execution patterns, component interaction rules

#### **‚ö†Ô∏è COMMON MISTAKES TO AVOID** ‚ö†Ô∏è
**Study these failure modes before implementation:**

- **Disconnected nodes** without proper input/output connections
- **Missing validation** after graph creation
- **Incorrect positioning** that creates unreadable graphs
- **Broken execution flow** that stops at incomplete nodes
- **Missing critical connections** that break experiment logic

#### **‚úÖ IMPLEMENTATION SAFETY CHECK** ‚ö†Ô∏è
**Before creating ANY node, verify:**

1. **Pattern Understanding**: Have you read the relevant GraphLogic rules?
2. **Connection Strategy**: Do you understand how this node connects to others?
3. **Validation Plan**: Do you know how to validate this node's implementation?
4. **Error Prevention**: Are you aware of common mistakes for this node type?
5. **Best Practices**: Do you understand the established patterns?

**üö® FAILURE TO FOLLOW THIS RULE RESULTS IN BROKEN GRAPHS AND EXPERIMENT FAILURES**

---

## üéØ **QUICK DECISION TREE**

### Need to show/hide objects?
‚Üí **Tools** category ‚Üí [GameObjectSetActiveStep](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc)

### Need to enable/disable colliders?
‚Üí **Tools** category ‚Üí [ToggleColliderStep](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc) ‚≠ê **CRITICAL RULE**

### Need user interaction in any order?
‚Üí **Control Flow** category ‚Üí [CompositeStep pattern](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc)

### Need sequential execution?
‚Üí **Chain: Node1.exit ‚Üí Node2.entry**

### Need function calls?
‚Üí **Function Call** category ‚Üí [FunctionCallStep](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc)

### Need multiple stages?
‚Üí **Create separate StepsGraph for each stage** ‚Üí Use GoToStageStep for transitions

### Need scenario selection?
‚Üí **Follow mandatory scenario pattern**: GameObjectSetActive ‚Üí ClickUI ‚Üí FunctionCall ‚Üí IfStatement

---

## üìÇ **STEP NODE CATEGORIES**

**Quick Reference**: [Attach-Detach](mdc:.cursor/rules/MCP/GraphLogic/Attach-DetachNodes.mdc) | [Click](mdc:.cursor/rules/MCP/GraphLogic/ClickNodes.mdc) | [Control Flow](mdc:.cursor/rules/MCP/GraphLogic/ControlFlowNodes.mdc) | [Camera](mdc:.cursor/rules/MCP/GraphLogic/CameraNodes.mdc) | [Function Call](mdc:.cursor/rules/MCP/GraphLogic/FunctionCallNodes.mdc) | [Loops](mdc:.cursor/rules/MCP/GraphLogic/LoopNodes.mdc) | [Tools](mdc:.cursor/rules/MCP/GraphLogic/ToolNodes.mdc) | [UI](mdc:.cursor/rules/MCP/GraphLogic/UINodes.mdc) | [Utility](mdc:.cursor/rules/MCP/GraphLogic/UtilityNodes.mdc) | [NewEvents](mdc:.cursor/rules/MCP/GraphLogic/NewEventsNodes.mdc) | [Table](mdc:.cursor/rules/MCP/GraphLogic/TableNodes.mdc) | [Progress Map](mdc:.cursor/rules/MCP/GraphLogic/ProgressMapNodes.mdc) | [Misc](mdc:.cursor/rules/MCP/GraphLogic/MiscNodes.mdc)

---

## üîó **ADDITIONAL REFERENCES**

- [Graph Validation Rules](mdc:.cursor/rules/MCP/graph-validation-rules.mdc) - Post-creation validation
- [Graph Connection Rules](mdc:.cursor/rules/MCP/graph-connection-rules.mdc) - Critical connection requirements
- [Positioning Strategy](mdc:.cursor/rules/MCP/positioning-strategy.mdc) - Node positioning guide
- [MCP Tools Reference](mdc:.cursor/rules/MCP/mcp-tools-reference.mdc) - Complete tool reference

**Remember**: When in doubt, always verify in the codebase first!








