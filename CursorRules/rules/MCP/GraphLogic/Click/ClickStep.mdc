---
alwaysApply: false
description: Pause graph execution until user clicks target object for interaction control
---

# ClickStep Node

## üìã Overview
ClickStep is a **WAIT-FOR-USER-INPUT** node that waits for user click before allowing execution to continue. **ClickStep does NOTHING by itself** - it only enables the execution path. The actual logic/functionality happens in the NEXT step(s) after the click.

## üîß Node Details

**Node Type**: ClickStep
**Purpose**: Wait for user click, then allow execution to continue to next step
**Usage**: User interaction gate, execution flow enabler
**‚ö†Ô∏è CRITICAL**: ClickStep alone does NOTHING - the next step contains the actual logic

## üìã Basic Prerequisites

1. **Collider**: Required on target object for click detection
2. **ClickableTool Script**: Required on target object to handle click events
3. **Hologram**: Optional visual indicator for clickable objects

## üìù Parameters

- **Target Object**: The object to be clicked (required for pause to work)

## üèóÔ∏è Common Patterns

### Click for Device Functionality (Non-Motion)
```
ClickStep (TV Remote) ‚Üí FunctionCallStep(TVController.TurnOff) ‚Üí Continue
ClickStep (Scale On Button) ‚Üí FunctionCallStep(ScaleController.TurnOn) ‚Üí Continue
ClickStep (Tare Button) ‚Üí FunctionCallStep(ScaleController.TareZero) ‚Üí Continue
ClickStep (Power Button) ‚Üí FunctionCallStep(DeviceController.PowerToggle) ‚Üí Continue
```

### Click for Motion/Physical Actions (Animation)
```
ClickStep (Bottle) ‚Üí AnimationStep(Bottle Opening Animation) ‚Üí Continue
ClickStep (Door) ‚Üí AnimationStep(Door Opening Animation) ‚Üí Continue
ClickStep (Drawer Handle) ‚Üí AnimationStep(Drawer Opening Animation) ‚Üí Continue
ClickStep (Hammer) ‚Üí AnimationStep(Crushing Animation) ‚Üí Continue
```

### Click to Show/Hide Objects
```
ClickStep (Panel Close Button) ‚Üí GameObjectSetActive(Panel, false) ‚Üí Continue
ClickStep (Menu Button) ‚Üí GameObjectSetActive(Menu, true) ‚Üí Continue
```

### Click to Control Camera
```
ClickStep (Microscope) ‚Üí FocusOnToolStep(Microscope) ‚Üí Continue
ClickStep (Bench Position) ‚Üí FunctionCallStep(SetMainBenchCamera) ‚Üí Continue
```

### Click in Branching Scenarios (OR Step)
```
OR Step
‚îú‚îÄ‚îÄ ClickStep (Option A) ‚Üí FunctionCall(ExecuteOptionA) ‚Üí Continue
‚îî‚îÄ‚îÄ ClickStep (Option B) ‚Üí FunctionCall(ExecuteOptionB) ‚Üí Continue
```
**Note**: Whichever click happens first determines the execution branch.

## üö® Critical ClickStep Rules
- **ClickStep = Gate**: ClickStep waits for user input, then enables execution flow to continue
- **No Standalone Logic**: ClickStep alone is USELESS - it does nothing by itself
- **Next Step = Actual Logic**: The step AFTER ClickStep contains the real functionality
- **Always Connect**: ClickStep MUST connect to the step that executes the desired logic
- **Branching Behavior**: In OR/branching scenarios, whichever ClickStep gets clicked first determines the execution path

## ‚ö†Ô∏è Common Mistakes

1. **Using ClickStep alone**: ClickStep without next steps is completely useless
2. **Expecting ClickStep to do logic**: ClickStep does NOTHING - the next step does the actual work
3. **Missing the actual logic step**: Forgetting to add FunctionCallStep/AnimationStep/etc. after ClickStep
4. **Wrong function reference**: "Click to turn off TV" needs TVController.TurnOff function call after ClickStep
5. **Missing object verification**: Always verify clicked object exists in registry
6. **Invalid object references**: Verify target objects are valid and have required scripts

## üéØ Best Practices

1. **Always connect to logic step**: Every ClickStep MUST connect to a step that does actual work
2. **Choose correct action type**:
   - **Motion/Physical actions** ‚Üí AnimationStep (opening, closing, moving, crushing, etc.)
   - **Device functionality** ‚Üí FunctionCallStep (turn on/off, tare/zero, power toggle, etc.)
3. **Identify the required controller**: "Click to turn off TV" ‚Üí find TVController with TurnOff method
4. **Provide visual feedback**: Use next steps to show the result of the click action
5. **Verify object existence**: Always verify clicked objects exist in registry before setup
6. **Test click sequences**: Thoroughly test that clicks trigger the expected functionality
7. **Handle edge cases**: Consider what happens if required controllers/methods don't exist

## üìù Implementation Checklist

When implementing "Click X to do Y":
1. ‚úÖ Create ClickStep targeting object X
2. ‚úÖ Determine if Y is motion-related or device functionality:
   - **Motion** (open, close, move, crush) ‚Üí AnimationStep
   - **Device function** (turn on/off, tare, power) ‚Üí FunctionCallStep
3. ‚úÖ Connect ClickStep ‚Üí AnimationStep(Y Animation) OR FunctionCallStep(XController.DoY)
4. ‚úÖ Add any visual feedback steps after the action
5. ‚úÖ Test that clicking X actually executes Y functionality

## üéØ Action Type Decision Guide

**Use AnimationStep for:**
- Opening/closing (bottles, doors, drawers, containers)
- Moving objects (dragging, lifting, placing)
- Physical transformations (crushing, breaking, mixing)
- Any visible motion or physical change

**Use FunctionCallStep for:**
- Device controls (power on/off, tare/zero, mode changes)
- System functions (save, load, calculate, process)
- Data operations (record, measure, analyze)
- Logical state changes (enable/disable, activate/deactivate)