---
alwaysApply: false
description: Core logic for control flow nodes and critical graph validation rules. Contains mandatory connection requirements, graph structure validation, and parallel execution patterns using CompositeStep.
---

# Control Flow Nodes

## üìã Overview
Control Flow nodes manage execution flow and branching logic in virtual lab experiments. These nodes are essential for decision making, parallel execution, and state management.

## üö® CRITICAL GRAPH VALIDATION RULES ‚ö†Ô∏è

### **MANDATORY GRAPH STRUCTURE REQUIREMENTS**

1. **Single Entry Point Rule**: 
   - **EVERY graph MUST have exactly ONE first step**
   - **NEVER create graphs without a designated entry point**
   - Use `set_node_as_first_step` to establish the entry point

2. **No Disconnected Nodes Rule**:
   - **ALL nodes must be connected to the execution flow**
   - **NEVER leave nodes floating without connections**
   - Every node must have a path from entry to exit

3. **Single Connected Graph Rule**:
   - **There must be ONE unified execution flow**
   - **NO multiple disconnected sub-graphs**
   - **NO isolated execution paths**
   - All logic must connect through a single entry point
   - Multiple ending points are allowed, but must share the same entry

4. **Post-Creation Validation Rule**:
   - **AFTER creating ANY graph, ALWAYS verify node connectivity**
   - **Use `list_graph_nodes` to check for disconnected nodes**
   - **Remove any nodes that aren't part of the execution flow**
   - **Verify all nodes have proper input/output connections**

### **VALIDATION CHECKLIST**
- ‚úÖ Graph has exactly one first step
- ‚úÖ All nodes are connected to the execution flow
- ‚úÖ No floating/disconnected nodes exist
- ‚úÖ Single unified execution path from entry
- ‚úÖ All routes eventually lead to completion
- ‚úÖ Post-creation validation completed

**VIOLATION OF THESE RULES WILL RESULT IN BROKEN EXPERIMENTS**

---

## üö® MANDATORY POST-CREATION VALIDATION ‚ö†Ô∏è

### **CRITICAL: After Creating ANY Graph**

**You MUST perform these validation steps:**

1. **Run `list_graph_nodes`** to get complete node list
2. **Check for disconnected nodes** - any node without proper connections
3. **Remove orphaned nodes** that aren't part of execution flow
4. **Verify all nodes have both input AND output connections** (except first/last)
5. **Confirm execution flow is complete** from entry to exit

### **MANDATORY VALIDATION LOOP RULE** ‚ö†Ô∏è
**After ANY correction, you MUST re-validate and continue the fix‚Üívalidate cycle until 100% error-free.**

**Example Flow:**
1. Create graph ‚Üí Validate ‚Üí Find error
2. Fix error ‚Üí **RE-VALIDATE** ‚Üí Find another error
3. Fix error ‚Üí **RE-VALIDATE** ‚Üí Find another error
4. Continue until validation shows 0 errors
5. **NEVER stop at first fix - always complete the full validation cycle**

### **Validation Commands**
```bash
# Check graph structure
mcp_unityMCP_list_graph_nodes "path/to/your/graph.asset"

# Look for nodes with 0 connections or missing ports
# Remove any disconnected nodes immediately
```

**FAILURE TO VALIDATE WILL RESULT IN BROKEN EXPERIMENTS**

---

## üö® CRITICAL NODE SELECTION RULES ‚ö†Ô∏è

### **RULE 3: CHOOSE THE RIGHT NODE BY CHECKING ITS RULE FILE**
**BEFORE creating ANY node from text interpretation:**
- **MANDATORY**: Read the rule file for the specific node type you plan to use
- **MANDATORY**: Check the "Common Mistakes" section of that node's rule file
- **MANDATORY**: Verify the node's purpose matches your intended use case
- **MANDATORY**: Understand the node's limitations and requirements before implementation
- **PURPOSE**: Ensure you're using the correct node for the correct purpose
- **IMPACT**: Wrong node selection leads to broken experiments and wasted time

### **Node Selection Process:**
1. **Interpret the text** to understand what action is needed
2. **Identify the node category** (UI, Tool, Control Flow, etc.)
3. **Read the specific rule file** for that node type
4. **Check the "Common Mistakes" section** to avoid documented errors
5. **Verify the node's purpose** matches your use case
6. **Only then create the node** with confidence

## üö® CRITICAL NODE CONNECTION RULES ‚ö†Ô∏è

### **MANDATORY NODE CONNECTION REQUIREMENTS**

1. **First Step Node Rule**: 
   - **NEVER connect TO the entry port of a first step node**
   - **MUST connect FROM the exit port of a first step node**
   - First step nodes can only have outgoing connections

2. **End Node Rule**: 
   - **NEVER connect FROM the exit port of an end node**
   - **MUST connect TO the entry port of an end node**
   - End nodes can only have incoming connections

3. **Middle Node Rule**: 
   - **ALL middle nodes MUST have BOTH incoming AND outgoing connections**
   - **Incoming**: From previous node's exit port
   - **Outgoing**: To next node's entry port
   - **Violation**: If a middle node lacks either connection, your logic is 100% incorrect

### **CONNECTION VALIDATION CHECKLIST**
- ‚úÖ First step: Only outgoing connections (exit port)
- ‚úÖ Middle nodes: Both incoming (entry) and outgoing (exit) connections
- ‚úÖ End nodes: Only incoming connections (entry port)
- ‚úÖ No floating nodes: Every node must be part of the execution flow

**VIOLATION OF THESE RULES WILL RESULT IN BROKEN EXPERIMENTS**

## üîß Available Nodes

### CompositeStep ‚≠ê CRITICAL PATTERN
**File**: [CompositeStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/CompositeStep.cs)
**Purpose**: Parallel execution management
**Usage**: used in the cases where we have multiple branches and all of the branches must be executing at any order.


**Connection Pattern**:
```
Start ‚Üí CompositeStep.entry
CompositeStep.routes ‚Üí Route A ‚Üí Logic ‚Üí CompositeStep.entry
CompositeStep.routes ‚Üí Route B ‚Üí Logic ‚Üí CompositeStep.entry  
CompositeStep.exit ‚Üí Continue
```
**When to Use**:
- Multiple user interactions in any order
- Parallel data collection
- Independent setup procedures

### IfStatementStep
**Purpose**: Boolean conditional branching
**Outputs**: `True`, `False`
**Usage**: Decision points, error checking
**Best Practices**:
- Use clear boolean conditions
- Handle both True and False cases
- Connect to appropriate responses

### SwitchStep / SwitchEnumStep
**Purpose**: Multi-way branching
**Usage**: State machines, menu systems
**Best Practices**:
- Use for multiple choice scenarios
- Handle all possible cases
- Connect to appropriate responses


### OR Step
**Purpose**: Logical Or-ing of two or more sequenece branches,
**Usage**: when having multiple routes that you have to take only one of them.

**Best Practices**:
- Use for multiple choice scenarios where a single choice will do the trick.


### First Then
**Purpose**: Multi-way branching
**Usage**: State machines, menu systems
**Best Practices**:
- Use for multiple choice scenarios
- Handle all possible cases
- Connect to appropriate responses


## üèóÔ∏è Common Patterns

### Parallel User Interactions
```
CompositeStep.entry ‚Üê Setup
CompositeStep.routes ‚Üí ClickStep A ‚Üí Action A ‚Üí CompositeStep.entry
CompositeStep.routes ‚Üí ClickStep B ‚Üí Action B ‚Üí CompositeStep.entry
CompositeStep.exit ‚Üí Completion
```

### Conditional Execution
```
IfStatementStep (Check condition) ‚Üí True: Execute Action A ‚Üí Continue
                                ‚Üí False: Execute Action B ‚Üí Continue
```

### Multi-way Decision
```
SwitchStep (User choice) ‚Üí Case 1: Action A ‚Üí Continue
                         ‚Üí Case 2: Action B ‚Üí Continue
                         ‚Üí Case 3: Action C ‚Üí Continue
```

### State Machine Pattern
```
SwitchStep (Current state) ‚Üí State A: Actions ‚Üí SwitchStep (Next state)
                          ‚Üí State B: Actions ‚Üí SwitchStep (Next state)
                          ‚Üí State C: Actions ‚Üí SwitchStep (Next state)
```

### Multiple choices where you have to choose one of them to procede

```
OR Step (Current state) ‚Üí State A: Actions ‚Üí SwitchStep (Next state)  -- Option 1 
                        ‚Üí State B: Actions ‚Üí SwitchStep (Next state)  -- Option 2            --Pick one of them
                        ‚Üí State C: Actions ‚Üí SwitchStep (Next state)  -- Option 3
```

### Multiple choices where you have to try all of the branches at any order in order for the step to execution to end

```
Composite Step (Current state) ‚Üí State A: Actions ‚Üí SwitchStep (Next state)  -- Option 1 
                               ‚Üí State B: Actions ‚Üí SwitchStep (Next state)  -- Option 2            --Pick one of them
                               ‚Üí State C: Actions ‚Üí SwitchStep (Next state)  -- Option 3
```

### Error Handling Pattern
```
IfStatementStep (Check for error) ‚Üí True: ShowErrorMessage ‚Üí Return
                                 ‚Üí False: Continue normal flow
```

### Scenario-Based Branching Pattern
```
IfStatementStep (IsScenarioA) ‚Üí True: ShowScenarioATools ‚Üí ExecuteScenarioA
                              ‚Üí False: ShowScenarioBTools ‚Üí ExecuteScenarioB

context: Used when user must choose between different experiment paths
```

### Completion Check Flow Pattern
```
FunctionCallStep (HasCompletedScenario) ‚Üí IfStatementStep ‚Üí True: ShowCompletionMessage
                                        ‚Üí False: ContinueExperiment

context: Check if user has completed a scenario before proceeding
```

### Multi-Position Selection Pattern
```
CompositeStep.entry ‚Üê Setup
CompositeStep.routes ‚Üí ClickStep (Position A) ‚Üí SetCamera ‚Üí ToggleColliders ‚Üí CompositeStep.entry
CompositeStep.routes ‚Üí ClickStep (Position B) ‚Üí SetCamera ‚Üí ToggleColliders ‚Üí CompositeStep.entry
CompositeStep.routes ‚Üí ClickStep (Position C) ‚Üí SetCamera ‚Üí ToggleColliders ‚Üí CompositeStep.entry
CompositeStep.exit ‚Üí Continue

context: Multiple positions that can be selected in any order, each with camera and collider management
```

### Interactive Setup Pattern
```
CompositeStep.entry ‚Üê ShowLoadingScreen
CompositeStep.routes ‚Üí UserAction A ‚Üí Response A ‚Üí CompositeStep.entry
CompositeStep.routes ‚Üí UserAction B ‚Üí Response B ‚Üí CompositeStep.entry
CompositeStep.exit ‚Üí Continue

context: Setup phase with multiple user interactions that can be completed in any order
```

### Sequential Experiment Flow Pattern
```
IntroEndMessagesStep ‚Üí Exploration_Step ‚Üí SubGraphStep (Step_01) ‚Üí SubGraphStep (Step_02) ‚Üí Continue

context: Linear progression through experiment phases with clear entry and exit points
```

### Step-Numbered Progression Pattern
```
SubGraphStep (Step_01, stepNumber: 1) ‚Üí SubGraphStep (Step_02, stepNumber: 2) ‚Üí 
SubGraphStep (Step_03, stepNumber: 3) ‚Üí SubGraphStep (Step_04, stepNumber: 4) ‚Üí Continue

context: Use stepNumber parameter to maintain clear experiment progression order
```

### Modular Phase Execution Pattern
```
SubGraphStep (Phase 1) ‚Üí ProgressMapManualNextStep ‚Üí SubGraphStep (Phase 2) ‚Üí 
ProgressMapManualNextStep ‚Üí SubGraphStep (Phase 3) ‚Üí Continue

context: Execute experiment phases sequentially with progress navigation between phases
```

### Delay-Initiated Sequential Flow Pattern
```
DelayStep (0.3s) ‚Üí HintStep (stepNumber: 1) ‚Üí SubGraphStep (Step_01) ‚Üí 
HintStep (stepNumber: 2) ‚Üí SubGraphStep (Step_02) ‚Üí Continue

context: Start experiment flow with delay and sequential hint guidance
```

### Auto-Progress Sequential Flow Pattern
```
SubGraphStep (Step_01) ‚Üí ProgressMapAutoNextStep ‚Üí SubGraphStep (Step_02) ‚Üí 
ProgressMapAutoNextStep ‚Üí SubGraphStep (Step_03) ‚Üí ProgressMapAutoNextStep ‚Üí Continue

context: Execute sequential steps with automatic progress navigation
```

### Hint-Guided Sequential Flow Pattern
```
HintStep (stepNumber: 1) ‚Üí SubGraphStep (Phase 1) ‚Üí HintStep (stepNumber: 2) ‚Üí 
SubGraphStep (Phase 2) ‚Üí HintStep (stepNumber: 3) ‚Üí SubGraphStep (Phase 3) ‚Üí Continue

context: Use sequential hints to guide users through experiment phases
```

## ‚ö†Ô∏è Common Mistakes

1. **Wrong CompositeStep connections**: Routes must connect back to entry 
2. **Missing False case**: Always handle both True and False in IfStatementStep
3. **Incomplete Switch cases**: Handle all possible cases in SwitchStep
4. **Wrong port connections**: Verify entry/exit/routes port names
5. **Missing first step**: Every graph MUST have exactly one first step
6. **Disconnected nodes**: All nodes must be connected to execution flow
7. **Multiple disconnected graphs**: All logic must share single entry point
8. **Missing post-creation validation**: ALWAYS verify node connectivity after graph creation
9. **Orphaned nodes**: Remove any nodes that aren't part of the execution flow
10. **Wrong node selection**: ALWAYS check the rule file for the specific node type before creating it
11. **Text interpretation errors**: When interpreting text as a node, verify the node's purpose in its rule file first
12. **Missing node validation**: Before creating any node, read its "Common Mistakes" section to avoid documented errors

## üîç Debugging Tips

1. **Test connections** one route at a time
2. **Verify port names** exist on nodes
3. **Check flow direction** (output ‚Üí input)
4. **Use DelayStep** to slow down execution for debugging (see [UtilityNodes.mdc](mdc:.cursor/rules/MCP/GraphLogic/UtilityNodes.mdc))
5. **Validate graph structure** using the critical rules above
6. **Post-Creation Validation**: Always run `list_graph_nodes` after graph creation to identify disconnected nodes
7. **Clean Up Orphans**: Remove any nodes that aren't connected to the execution flow