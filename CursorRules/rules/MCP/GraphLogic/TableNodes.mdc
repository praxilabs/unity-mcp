---
alwaysApply: false
description: Data table operations, record management, and stage data handling. Contains table interaction steps, record operations, and data management patterns.
---
# Table Nodes

## 📋 Overview
Table nodes handle data table operations and stage management in virtual lab experiments. These nodes are essential for data management, interactive table operations, and tracking experiment progress through stages.

## 🔧 Available Nodes

### AddRecordStep
**Purpose**: Add a new record (row) to the active data table
**Usage**: Data collection, logging experiment results, populating tables dynamically
**Best Practices**:
- Ensure the target table is active and accessible
- Provide all necessary data fields for the new record
- Use in conjunction with UI feedback to confirm record addition

### EnableStageStep
**Purpose**: Activate or initialize a new stage in the experiment flow
**Usage**: Marking the beginning of a new phase, enabling specific functionalities for a stage
**Best Practices**:
- Clearly define the conditions for enabling a new stage
- Use to control the flow and progression of the experiment
- Can be linked to UI updates to show current stage

### EnableRecordButtonStep
**Purpose**: Enable or disable a UI button responsible for triggering a record operation
**Usage**: User-controlled data recording, interactive data capture
**Best Practices**:
- Connect to user interaction steps (e.g., ClickStep) to trigger recording
- Ensure the button's state (enabled/disabled) reflects the current context
- Provide visual feedback when the button is enabled or disabled

### SetCurrentStageStep
**Purpose**: Explicitly set the current active stage of the experiment
**Usage**: Navigating between stages, resuming an experiment from a specific point
**Best Practices**:
- Use for direct control over the experiment's progress
- Ensure stage names or identifiers are consistent
- Can be used for branching logic based on the current stage

### SetStagePassedStep
**Purpose**: Mark a specific stage as successfully completed
**Usage**: Tracking progress, validating completion of a phase, unlocking subsequent stages
**Best Practices**:
- Only set a stage as passed after all its requirements are met
- Can trigger events or UI changes indicating stage completion
- Essential for linear or sequential experiment flows

### UnsetStagePassedStep
**Purpose**: Revert the 'passed' status of a stage, marking it as incomplete or failed
**Usage**: Error handling, resetting a stage for re-attempt, branching based on failure
**Best Practices**:
- Use carefully, typically for error states or retry mechanisms
- Provide clear feedback to the user when a stage's passed status is unset
- Can be used to loop back to a previous stage or trigger corrective actions

## 🏗️ Common Patterns

### Data Table Record Management
```
// Add a new record
AddRecordStep (Table, Data) → Continue

// Enable a record button for user interaction
EnableRecordButtonStep (ButtonID, true) → ClickStep (RecordButton) → AddRecordStep (Table, UserData) → Continue
```

### Stage Progression Control
```
// Linear stage progression
EnableStageStep (Stage1) → LogicForStage1 → SetStagePassedStep (Stage1) → EnableStageStep (Stage2) → Continue

// Conditional stage setting
IfStatementStep (Condition) → SetCurrentStageStep (SuccessStage) → Continue
IfStatementStep (NOT Condition) → SetCurrentStageStep (FailureStage) → Continue

// Resetting a stage
ActionFails → UnsetStagePassedStep (CurrentStage) → RetryLogic → Continue
```

### Interactive Table Operations
```
// User adds data via UI
EnableRecordButtonStep (RecordButton) → UserInputStep (Data) → AddRecordStep (ActiveTable, UserInputData) → Continue
```

### Experiment Flow with Stages
```
// Complete experiment flow with stage management
EnableStageStep (Setup) → SetupLogic → SetStagePassedStep (Setup) → 
EnableStageStep (Experiment) → ExperimentLogic → SetStagePassedStep (Experiment) → 
EnableStageStep (Analysis) → AnalysisLogic → SetStagePassedStep (Analysis) → Continue
```

### Error Handling with Stage Reset
```
// If experiment fails, reset stage
ExperimentLogic → IfStatementStep (Success) → SetStagePassedStep (CurrentStage) → Continue
                              → False: UnsetStagePassedStep (CurrentStage) → ShowMessage (Retry) → RetryLogic
```

## ⚠️ Common Mistakes

1. **Missing stage validation**: Always verify stage requirements before marking as passed
2. **Inconsistent stage names**: Use consistent naming conventions for stages
3. **Missing error handling**: Always handle stage failures with UnsetStagePassedStep
4. **Incomplete data records**: Ensure all required fields are provided for table records
5. **Wrong button states**: Ensure record buttons are enabled/disabled appropriately

## 🔍 Debugging Tips

1. **Test stage progression** one stage at a time
2. **Verify table data** is being recorded correctly
3. **Check stage status** after each stage operation
4. **Monitor button states** for record operations
5. **Use DelayStep** to slow down for debugging
6. **Verify stage names** are consistent throughout the experiment
2. **Verify data flow** is complete
3. **Check table references** are valid
4. **Use DelayStep** to slow down for debugging

# Table Nodes

## 📋 Overview
Table nodes handle data table operations and stage management in virtual lab experiments. These nodes are essential for data management, interactive table operations, and tracking experiment progress through stages.

## 🔧 Available Nodes

### AddRecordStep
**Purpose**: Add a new record (row) to the active data table
**Usage**: Data collection, logging experiment results, populating tables dynamically
**Best Practices**:
- Ensure the target table is active and accessible
- Provide all necessary data fields for the new record
- Use in conjunction with UI feedback to confirm record addition

### EnableStageStep
**Purpose**: Activate or initialize a new stage in the experiment flow
**Usage**: Marking the beginning of a new phase, enabling specific functionalities for a stage
**Best Practices**:
- Clearly define the conditions for enabling a new stage
- Use to control the flow and progression of the experiment
- Can be linked to UI updates to show current stage

### EnableRecordButtonStep
**Purpose**: Enable or disable a UI button responsible for triggering a record operation
**Usage**: User-controlled data recording, interactive data capture
**Best Practices**:
- Connect to user interaction steps (e.g., ClickStep) to trigger recording
- Ensure the button's state (enabled/disabled) reflects the current context
- Provide visual feedback when the button is enabled or disabled

### SetCurrentStageStep
**Purpose**: Explicitly set the current active stage of the experiment
**Usage**: Navigating between stages, resuming an experiment from a specific point
**Best Practices**:
- Use for direct control over the experiment's progress
- Ensure stage names or identifiers are consistent
- Can be used for branching logic based on the current stage

### SetStagePassedStep
**Purpose**: Mark a specific stage as successfully completed
**Usage**: Tracking progress, validating completion of a phase, unlocking subsequent stages
**Best Practices**:
- Only set a stage as passed after all its requirements are met
- Can trigger events or UI changes indicating stage completion
- Essential for linear or sequential experiment flows

### UnsetStagePassedStep
**Purpose**: Revert the 'passed' status of a stage, marking it as incomplete or failed
**Usage**: Error handling, resetting a stage for re-attempt, branching based on failure
**Best Practices**:
- Use carefully, typically for error states or retry mechanisms
- Provide clear feedback to the user when a stage's passed status is unset
- Can be used to loop back to a previous stage or trigger corrective actions

## 🏗️ Common Patterns

### Data Table Record Management
```
// Add a new record
AddRecordStep (Table, Data) → Continue

// Enable a record button for user interaction
EnableRecordButtonStep (ButtonID, true) → ClickStep (RecordButton) → AddRecordStep (Table, UserData) → Continue
```

### Stage Progression Control
```
// Linear stage progression
EnableStageStep (Stage1) → LogicForStage1 → SetStagePassedStep (Stage1) → EnableStageStep (Stage2) → Continue

// Conditional stage setting
IfStatementStep (Condition) → SetCurrentStageStep (SuccessStage) → Continue
IfStatementStep (NOT Condition) → SetCurrentStageStep (FailureStage) → Continue

// Resetting a stage
ActionFails → UnsetStagePassedStep (CurrentStage) → RetryLogic → Continue
```

### Interactive Table Operations
```
// User adds data via UI
EnableRecordButtonStep (RecordButton) → UserInputStep (Data) → AddRecordStep (ActiveTable, UserInputData) → Continue
```

### Experiment Flow with Stages
```
// Complete experiment flow with stage management
EnableStageStep (Setup) → SetupLogic → SetStagePassedStep (Setup) → 
EnableStageStep (Experiment) → ExperimentLogic → SetStagePassedStep (Experiment) → 
EnableStageStep (Analysis) → AnalysisLogic → SetStagePassedStep (Analysis) → Continue
```

### Error Handling with Stage Reset
```
// If experiment fails, reset stage
ExperimentLogic → IfStatementStep (Success) → SetStagePassedStep (CurrentStage) → Continue
                              → False: UnsetStagePassedStep (CurrentStage) → ShowMessage (Retry) → RetryLogic
```

## ⚠️ Common Mistakes

1. **Missing stage validation**: Always verify stage requirements before marking as passed
2. **Inconsistent stage names**: Use consistent naming conventions for stages
3. **Missing error handling**: Always handle stage failures with UnsetStagePassedStep
4. **Incomplete data records**: Ensure all required fields are provided for table records
5. **Wrong button states**: Ensure record buttons are enabled/disabled appropriately

## 🔍 Debugging Tips

1. **Test table operations** one step at a time
2. **Verify table data** is correct
3. **Check table references** exist
4. **Use DelayStep** to slow down for debugging
5. **Monitor table operations** with console logs
6. **Test table sequences** end-to-end
7. **Validate table results** and outputs
8. **Check table dependencies** and prerequisites

