---
alwaysApply: false
description: System utility operations, timing control, and modular execution. Contains FreezeLabStep, DelayStep, SubGraphStep, and utility operation patterns.
---

# Utility Nodes

## 📋 Overview
Utility nodes handle system utility operations in virtual lab experiments. These nodes are essential for system control, timing, and modular execution.

## 🔧 Available Nodes

### FreezeLabStep
**Purpose**: Freeze/unfreeze lab interactions
**Usage**: Pause functionality, modal dialogs
**Best Practices**:
- Use for system-wide pause functionality
- Connect to modal or pause scenarios
- Use with clear user feedback

### DelayStep
**Purpose**: Wait for specified time
**Usage**: Timing between actions, pacing experiments
**Best Practices**:
- Set appropriate delay duration
- Use for pacing and timing control
- Connect to timing-dependent actions

### ExplorationStep
**Purpose**: A Transition Step to make you explore each item that you will use in the scene.
**Usage**: Exploring Tools for Beginners,
**Best Practices**:
- Set appropriate delay duration
- Use for pacing and timing control
- Connect to timing-dependent actions



### SubGraphStep
**Purpose**: Execute other graphs as subroutines
**Usage**: Modular experiment design, reusable procedures
**Best Practices**:
- Use for modular experiment design
- Create reusable sub-procedures
- Connect to main experiment flow

## 🏗️ Common Patterns

### System Pause Pattern
```
FreezeLabStep (freeze) → ShowMessage (System paused) → UserAction → FreezeLabStep (unfreeze) → Continue
```

### Timing Control Pattern
```
Action A → DelayStep (wait) → Action B → Continue
```

### Modular Execution Pattern
```
SubGraphStep (Setup procedure) → Main experiment → SubGraphStep (Cleanup procedure) → Continue
```

### Paced Sequence Pattern
```
Action → DelayStep → Action → DelayStep → Action → Continue
```

### Modal Dialog Pattern
```
FreezeLabStep (freeze) → ShowMessage (Modal dialog) → UserAction → FreezeLabStep (unfreeze) → Continue
```

### Reusable Procedure Pattern
```
SubGraphStep (Common setup) → Specific action → SubGraphStep (Common cleanup) → Continue
```

### Completion Flow Delay Pattern
```
FunctionCallStep (MarkScenarioComplete) → DelayStep (0.3s) → ShowCompletionMessage

context: Add small delay after marking completion for better user experience
```

### Message Transition Delay Pattern
```
ShowMessage → DelayStep (0.5s) → ShowNextMessage

context: Use delays between messages for better readability and pacing
```

### Exploration Step usage
```
IntroEndMessageStep → MiddleMessageTwoActionsStep(do you want to get to exploration phase?) [yes] → ExplorationStep
                                                                                            [No] → continue
```

### Loading Screen Delay Pattern
```
FunctionCallStep (ShowLoadingScreen) → DelayStep (1.0s) → Continue

context: Add delay after loading screen for better user experience
```

### Camera Transition Delay Pattern
```
FunctionCallStep (GoToBirdEye) → DelayStep (0.2s) → FunctionCallStep (ToggleBirdEyeUI) → Continue

context: Small delay between camera movements for smooth transitions
```

### Experiment Start Delay Pattern
```
DelayStep (0.3s) → HintStep (stepNumber: 1) → SubGraphStep (Step_01) → Continue

context: Add initial delay before starting experiment for user preparation
```

### Step Transition Delay Pattern
```
SubGraphStep (Complete step) → DelayStep (0.3s) → HintStep (Next step) → Continue

context: Use consistent delays between experiment steps for better pacing
```

### Hint Step Delay Integration Pattern
```
HintStep (stepNumber: current) → DelayStep (0.3s) → SubGraphStep (Next phase) → Continue

context: Integrate delays with hint steps for smooth experiment progression
```

## ⚠️ Common Mistakes

1. **Missing unfreeze**: Always unfreeze after freezing
2. **Wrong delay duration**: Set appropriate timing for delays
3. **Infinite subgraphs**: Avoid circular subgraph references
4. **Missing user feedback**: Provide clear feedback for utility operations

## 🔍 Debugging Tips

1. **Test utility operations** one step at a time
2. **Verify timing** is appropriate for delays
3. **Check subgraph references** are valid
4. **Use DelayStep** to slow down execution for debugging
5. **Monitor system state** for freeze/unfreeze operations
