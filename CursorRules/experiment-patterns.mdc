---
description: Proven experiment design patterns for Unity MCP Bridge with real-world examples and templates
---

# Experiment Design Patterns

## 🎓 Educational Experiment Pattern

### Characteristics
- **Purpose**: Guided learning with user-paced progression
- **Focus**: Understanding concepts through interaction
- **Flow**: Linear with user control points
- **Complexity**: Low to moderate control flow

### Structure Template
```
1. Introduction Phase: IntroEndMessagesStep + HintStep
2. Setup Phase: GameObjectSetActiveStep chain
3. Guided Interaction: HintStep → User Action → Feedback
4. Educational Reinforcement: HintStep between phases
5. User Pacing: Manual progression controls
6. Completion: Results display + summary
```

### Real Example: PhotoElectric Effect
```
Start → IntroEndMessagesStep (welcome)
  ↓
HintStep (setup instructions)
  ↓
GameObjectSetActiveStep (show equipment)
  ↓
DelayStep (1.5s)
  ↓
HintStep (interaction guidance)
  ↓
ClickStep (user clicks equipment)
  ↓
FunctionCallStep (activate measurement)
  ↓
HintStep (explain results)
  ↓
SideMessageStep (completion)
```

### Key Features
- Heavy use of HintStep for guidance
- DelayStep for pacing
- Sequential progression (no complex loops)
- Clear feedback at each step
- Educational context at transitions

## 🔬 Research Experiment Pattern

### Characteristics
- **Purpose**: Data collection and systematic analysis
- **Focus**: Precise measurements and controls
- **Flow**: Complex with loops and conditions
- **Complexity**: High control flow usage

### Structure Template
```
1. Calibration Phase: Equipment setup and validation
2. Parameter Control: Variable manipulation
3. Measurement Loop: Systematic data collection
4. Data Analysis: Real-time processing
5. Adaptive Logic: Conditional branching based on results
6. Error Handling: Retry mechanisms and validation
```

### Real Example: Material Properties Testing
```
Start → FunctionCallStep (calibrate equipment)
  ↓
ForLoopStep (iterations: 10)
  ├─ continueLoop → FunctionCallStep (set parameters)
  │                     ↓
  │                 ClickStep (user activates test)
  │                     ↓
  │                 DelayStep (measurement time)
  │                     ↓
  │                 FunctionCallStep (read sensors)
  │                     ↓
  │                 IfStatementStep (validate data)
  │                 ├─ True → Continue loop
  │                 └─ False → Error handling
  └─ exit → SwitchStep (analyze results)
              ├─ Case 1: Success message
              ├─ Case 2: Retry suggestion
              └─ Case 3: Error report
```

### Key Features
- ForLoopStep/WhileLoopStep for systematic testing
- IfStatementStep for validation and error handling
- SwitchStep for result categorization
- FunctionCallStep for precise control
- Data persistence and analysis

## 🎮 Interactive Demo Pattern

### Characteristics
- **Purpose**: Showcase capabilities and engage users
- **Focus**: Visual appeal and user engagement
- **Flow**: Parallel interactions with visual feedback
- **Complexity**: Moderate with emphasis on UX

### Structure Template
```
1. Attention Phase: Sequential object appearance
2. Interaction Phase: Parallel user choices
3. Response Phase: Immediate visual feedback
4. Completion Phase: Synchronized conclusion
```

### Real Example: Name Tag Experiment
```
Start → GameObjectSetActiveStep (hide all tags)
  ↓
GameObjectSetActiveStep (hide tag 2)
  ↓
GameObjectSetActiveStep (hide tag 3)
  ↓
DelayStep (1.5s)
  ↓
GameObjectSetActiveStep (show tag 1)
  ↓
DelayStep (1.5s)
  ↓
GameObjectSetActiveStep (show tag 2)
  ↓
GameObjectSetActiveStep (show tag 3)
  ↓
CompositeStep.entry ← All tags visible
CompositeStep.routes → ClickStep (tag 1) → GameObjectSetActiveStep (hide 1) → CompositeStep.entry
CompositeStep.routes → ClickStep (tag 2) → GameObjectSetActiveStep (hide 2) → CompositeStep.entry
CompositeStep.routes → ClickStep (tag 3) → GameObjectSetActiveStep (hide 3) → CompositeStep.entry
CompositeStep.exit → SideMessageStep (completion)
```

### Key Features
- Sequential appearance for visual impact
- CompositeStep for parallel interactions
- Immediate visual feedback
- Clear completion criteria
- Engaging user experience

## 📊 Data Collection Pattern

### Characteristics
- **Purpose**: Systematic data gathering and analysis
- **Focus**: Accuracy, repeatability, statistical validity
- **Flow**: Structured loops with data validation
- **Complexity**: High automation with user checkpoints

### Structure Template
```
1. Initialization Phase: Setup and calibration
2. Data Collection Loop: Automated measurements
3. User Validation: Manual verification points
4. Statistical Analysis: Real-time calculations
5. Quality Control: Error detection and correction
6. Results Export: Data storage and visualization
```

### Real Example: Multi-Point Measurement
```
Start → FunctionCallStep (initialize sensors)
  ↓
WhileLoopStep (condition: measurements < target)
  ├─ continueLoop → FunctionCallStep (position equipment)
  │                     ↓
  │                 DelayStep (stabilization)
  │                     ↓
  │                 FunctionCallStep (take measurement)
  │                     ↓
  │                 IfStatementStep (validate reading)
  │                 ├─ True → Store data + continue
  │                 └─ False → Retry measurement
  └─ exit → FunctionCallStep (calculate statistics)
              ↓
          SwitchStep (result quality)
          ├─ High: Export data
          ├─ Medium: Flag for review
          └─ Low: Suggest recalibration
```

### Key Features
- WhileLoopStep for flexible iteration
- Data validation at each step
- Error handling and retry logic
- Statistical analysis integration
- Quality control mechanisms

## 🔧 Maintenance and Troubleshooting Pattern

### Characteristics
- **Purpose**: System diagnostics and problem resolution
- **Focus**: Error detection, diagnosis, and correction
- **Flow**: Diagnostic trees with corrective actions
- **Complexity**: High branching logic

### Structure Template
```
1. System Check: Automated diagnostics
2. Problem Detection: Error identification
3. Diagnostic Tree: Systematic troubleshooting
4. Corrective Actions: Automated or guided fixes
5. Verification: Confirm resolution
6. Documentation: Log issues and solutions
```

## 🎯 Pattern Selection Guide

### Choose Educational Pattern When:
- Users are learning new concepts
- Step-by-step guidance is needed
- Understanding is more important than speed
- Linear progression makes sense

### Choose Research Pattern When:
- Precise data collection is required
- Multiple variables need control
- Statistical analysis is important
- Automation can improve accuracy

### Choose Interactive Demo When:
- Engagement is the primary goal
- Visual appeal matters
- User choice and agency are important
- Quick interaction cycles are preferred

### Choose Data Collection When:
- Large datasets are needed
- Repeatability is critical
- Quality control is essential
- Analysis integration is required

## 🔄 Pattern Combinations

### Educational + Interactive Demo
```
HintStep → Interactive Demo → HintStep → Analysis
```

### Research + Data Collection
```
Research Setup → Data Collection Loop → Statistical Analysis
```

### Interactive Demo + Educational
```
Engaging Demo → Educational Explanation → Guided Practice
```

## 📋 Pattern Implementation Checklist

### Before Starting:
- [ ] Identify primary pattern based on goals
- [ ] Plan user interaction points
- [ ] Design feedback mechanisms
- [ ] Consider error handling needs

### During Implementation:
- [ ] Follow pattern structure consistently
- [ ] Use appropriate step node types
- [ ] Implement proper connection patterns
- [ ] Add adequate timing and delays

### After Implementation:
- [ ] Test all user paths
- [ ] Verify error handling
- [ ] Confirm completion criteria
- [ ] Validate user experience flow

## ⚠️ Anti-Patterns (Avoid These)

### The "Everything Sequential" Anti-Pattern
```
❌ BAD: Click A → Click B → Click C (forced order)
✅ GOOD: CompositeStep with parallel routes
```

### The "No Feedback" Anti-Pattern
```
❌ BAD: Action → Silent completion
✅ GOOD: Action → Visual feedback → Confirmation
```

### The "Complex Single Node" Anti-Pattern
```
❌ BAD: One FunctionCallStep doing everything
✅ GOOD: Multiple specialized step nodes
```

### The "Ignore Errors" Anti-Pattern
```
❌ BAD: No error handling or validation
✅ GOOD: IfStatementStep for validation + error paths
```