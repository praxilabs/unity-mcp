---
description: Proven experiment design patterns for Unity MCP Bridge with real-world examples and templates
---

# Experiment Design Patterns

## ğŸ“ Educational Experiment Pattern

### Characteristics
- **Purpose**: Guided learning with user-paced progression
- **Focus**: Understanding concepts through interaction
- **Flow**: Linear with user control points
- **Complexity**: Low to moderate control flow

### Structure Template
```
1. Introduction Phase: IntroEndMessagesStep + HintStep
2. Setup Phase: GameObjectSetActiveStep chain
3. Guided Interaction: HintStep â†’ User Action â†’ Feedback
4. Educational Reinforcement: HintStep between phases
5. User Pacing: Manual progression controls
6. Completion: Results display + summary
```

### Real Example: PhotoElectric Effect
```
Start â†’ IntroEndMessagesStep (welcome)
  â†“
HintStep (setup instructions)
  â†“
GameObjectSetActiveStep (show equipment)
  â†“
DelayStep (1.5s)
  â†“
HintStep (interaction guidance)
  â†“
ClickStep (user clicks equipment)
  â†“
FunctionCallStep (activate measurement)
  â†“
HintStep (explain results)
  â†“
SideMessageStep (completion)
```

### Key Features
- Heavy use of HintStep for guidance
- DelayStep for pacing
- Sequential progression (no complex loops)
- Clear feedback at each step
- Educational context at transitions

## ğŸ”¬ Research Experiment Pattern

### Characteristics
- **Purpose**: Data collection and systematic analysis
- **Focus**: Precise measurements and controls
- **Flow**: Complex with loops and conditions
- **Complexity**: High control flow usage

### Structure Template
```
1. Calibration Phase: Equipment setup and validation
2. Parameter Control: Variable manipulation
3. Measurement Loop: Systematic data collection
4. Data Analysis: Real-time processing
5. Adaptive Logic: Conditional branching based on results
6. Error Handling: Retry mechanisms and validation
```

### Real Example: Material Properties Testing
```
Start â†’ FunctionCallStep (calibrate equipment)
  â†“
ForLoopStep (iterations: 10)
  â”œâ”€ continueLoop â†’ FunctionCallStep (set parameters)
  â”‚                     â†“
  â”‚                 ClickStep (user activates test)
  â”‚                     â†“
  â”‚                 DelayStep (measurement time)
  â”‚                     â†“
  â”‚                 FunctionCallStep (read sensors)
  â”‚                     â†“
  â”‚                 IfStatementStep (validate data)
  â”‚                 â”œâ”€ True â†’ Continue loop
  â”‚                 â””â”€ False â†’ Error handling
  â””â”€ exit â†’ SwitchStep (analyze results)
              â”œâ”€ Case 1: Success message
              â”œâ”€ Case 2: Retry suggestion
              â””â”€ Case 3: Error report
```

### Key Features
- ForLoopStep/WhileLoopStep for systematic testing
- IfStatementStep for validation and error handling
- SwitchStep for result categorization
- FunctionCallStep for precise control
- Data persistence and analysis

## ğŸ® Interactive Demo Pattern

### Characteristics
- **Purpose**: Showcase capabilities and engage users
- **Focus**: Visual appeal and user engagement
- **Flow**: Parallel interactions with visual feedback
- **Complexity**: Moderate with emphasis on UX

### Structure Template
```
1. Attention Phase: Sequential object appearance
2. Interaction Phase: Parallel user choices
3. Response Phase: Immediate visual feedback
4. Completion Phase: Synchronized conclusion
```

### Real Example: Name Tag Experiment
```
Start â†’ GameObjectSetActiveStep (hide all tags)
  â†“
GameObjectSetActiveStep (hide tag 2)
  â†“
GameObjectSetActiveStep (hide tag 3)
  â†“
DelayStep (1.5s)
  â†“
GameObjectSetActiveStep (show tag 1)
  â†“
DelayStep (1.5s)
  â†“
GameObjectSetActiveStep (show tag 2)
  â†“
GameObjectSetActiveStep (show tag 3)
  â†“
CompositeStep.entry â† All tags visible
CompositeStep.routes â†’ ClickStep (tag 1) â†’ GameObjectSetActiveStep (hide 1) â†’ CompositeStep.entry
CompositeStep.routes â†’ ClickStep (tag 2) â†’ GameObjectSetActiveStep (hide 2) â†’ CompositeStep.entry
CompositeStep.routes â†’ ClickStep (tag 3) â†’ GameObjectSetActiveStep (hide 3) â†’ CompositeStep.entry
CompositeStep.exit â†’ SideMessageStep (completion)
```

### Key Features
- Sequential appearance for visual impact
- CompositeStep for parallel interactions
- Immediate visual feedback
- Clear completion criteria
- Engaging user experience

## ğŸ“Š Data Collection Pattern

### Characteristics
- **Purpose**: Systematic data gathering and analysis
- **Focus**: Accuracy, repeatability, statistical validity
- **Flow**: Structured loops with data validation
- **Complexity**: High automation with user checkpoints

### Structure Template
```
1. Initialization Phase: Setup and calibration
2. Data Collection Loop: Automated measurements
3. User Validation: Manual verification points
4. Statistical Analysis: Real-time calculations
5. Quality Control: Error detection and correction
6. Results Export: Data storage and visualization
```

### Real Example: Multi-Point Measurement
```
Start â†’ FunctionCallStep (initialize sensors)
  â†“
WhileLoopStep (condition: measurements < target)
  â”œâ”€ continueLoop â†’ FunctionCallStep (position equipment)
  â”‚                     â†“
  â”‚                 DelayStep (stabilization)
  â”‚                     â†“
  â”‚                 FunctionCallStep (take measurement)
  â”‚                     â†“
  â”‚                 IfStatementStep (validate reading)
  â”‚                 â”œâ”€ True â†’ Store data + continue
  â”‚                 â””â”€ False â†’ Retry measurement
  â””â”€ exit â†’ FunctionCallStep (calculate statistics)
              â†“
          SwitchStep (result quality)
          â”œâ”€ High: Export data
          â”œâ”€ Medium: Flag for review
          â””â”€ Low: Suggest recalibration
```

### Key Features
- WhileLoopStep for flexible iteration
- Data validation at each step
- Error handling and retry logic
- Statistical analysis integration
- Quality control mechanisms

## ğŸ”§ Maintenance and Troubleshooting Pattern

### Characteristics
- **Purpose**: System diagnostics and problem resolution
- **Focus**: Error detection, diagnosis, and correction
- **Flow**: Diagnostic trees with corrective actions
- **Complexity**: High branching logic

### Structure Template
```
1. System Check: Automated diagnostics
2. Problem Detection: Error identification
3. Diagnostic Tree: Systematic troubleshooting
4. Corrective Actions: Automated or guided fixes
5. Verification: Confirm resolution
6. Documentation: Log issues and solutions
```

## ğŸ¯ Pattern Selection Guide

### Choose Educational Pattern When:
- Users are learning new concepts
- Step-by-step guidance is needed
- Understanding is more important than speed
- Linear progression makes sense

### Choose Research Pattern When:
- Precise data collection is required
- Multiple variables need control
- Statistical analysis is important
- Automation can improve accuracy

### Choose Interactive Demo When:
- Engagement is the primary goal
- Visual appeal matters
- User choice and agency are important
- Quick interaction cycles are preferred

### Choose Data Collection When:
- Large datasets are needed
- Repeatability is critical
- Quality control is essential
- Analysis integration is required

## ğŸ”„ Pattern Combinations

### Educational + Interactive Demo
```
HintStep â†’ Interactive Demo â†’ HintStep â†’ Analysis
```

### Research + Data Collection
```
Research Setup â†’ Data Collection Loop â†’ Statistical Analysis
```

### Interactive Demo + Educational
```
Engaging Demo â†’ Educational Explanation â†’ Guided Practice
```

## ğŸ“‹ Pattern Implementation Checklist

### Before Starting:
- [ ] Identify primary pattern based on goals
- [ ] Plan user interaction points
- [ ] Design feedback mechanisms
- [ ] Consider error handling needs

### During Implementation:
- [ ] Follow pattern structure consistently
- [ ] Use appropriate step node types
- [ ] Implement proper connection patterns
- [ ] Add adequate timing and delays

### After Implementation:
- [ ] Test all user paths
- [ ] Verify error handling
- [ ] Confirm completion criteria
- [ ] Validate user experience flow

## âš ï¸ Anti-Patterns (Avoid These)

### The "Everything Sequential" Anti-Pattern
```
âŒ BAD: Click A â†’ Click B â†’ Click C (forced order)
âœ… GOOD: CompositeStep with parallel routes
```

### The "No Feedback" Anti-Pattern
```
âŒ BAD: Action â†’ Silent completion
âœ… GOOD: Action â†’ Visual feedback â†’ Confirmation
```

### The "Complex Single Node" Anti-Pattern
```
âŒ BAD: One FunctionCallStep doing everything
âœ… GOOD: Multiple specialized step nodes
```

### The "Ignore Errors" Anti-Pattern
```
âŒ BAD: No error handling or validation
âœ… GOOD: IfStatementStep for validation + error paths
```