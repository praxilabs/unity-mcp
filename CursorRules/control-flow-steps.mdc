---
description: These Rules are conditions of usage and best practicies for the control flow steps.
alwaysApply: false
---
# Control Flow Step Nodes

Control flow step nodes manage the execution logic and branching in experiment workflows. These nodes inherit from `SelfExectutedStep` and provide conditional execution, loops, and complex branching patterns.

## Location
**Directory**: `Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/`

## Conditional Branching

### IfStatementStep
- **File**: [IfStatementStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/IfStatementStep.cs)
- **NodeTint**: `#643843` (Dark Purple)
- **Menu Path**: "Control Flow/If Statement Step"
- **Purpose**: Simple conditional branching based on boolean input
- **Parameters**:
  - `entry` (NodeObject): Boolean input condition
- **Outputs**:
  - `True`: Execution path when condition is true
  - `False`: Execution path when condition is false
- **Behavior**: Evaluates boolean input and routes execution accordingly
- **Use Cases**: Simple yes/no decisions, error checking, condition validation

### SwitchStep
- **File**: [SwitchStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/SwitchStep.cs)
- **Purpose**: Multi-way branching based on input value
- **Parameters**:
  - `entry` (NodeObject): Switch value to evaluate
- **Outputs**: Multiple output ports for different cases
- **Behavior**: Routes execution based on input value matching specific cases
- **Use Cases**: State machines, menu systems, multi-option decisions

### SwitchEnumStep
- **File**: [SwitchEnumStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/SwitchEnumStep.cs)
- **Purpose**: Enum-based switching for type-safe branching
- **Parameters**:
  - `entry` (NodeObject): Enum value to evaluate
- **Outputs**: Output ports corresponding to enum values
- **Behavior**: Routes execution based on enum value
- **Use Cases**: Experiment phases, measurement types, material states

## Sequential Execution

### FirstThenStep
- **File**: [FirstThenStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/FirstThenStep.cs)
- **Purpose**: Execute first branch, then second branch sequentially
- **Outputs**:
  - `first`: First execution path
  - `then`: Second execution path (executes after first completes)
- **Behavior**: Executes first path completely, then second path
- **Use Cases**: Setup then measurement, calibration then testing, preparation then execution

### CompositeStep
- **File**: [CompositeStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/CompositeStep.cs)
- **Purpose**: Combine multiple steps into a single execution unit
- **Parameters**: Multiple input steps
- **Behavior**: Executes multiple steps in sequence as a single unit
- **Use Cases**: Complex procedures, multi-step operations, grouped actions

## Complex Branching

### BranchingControlStep
- **File**: [BranchingControlStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/BranchingControlStep.cs)
- **Purpose**: Advanced branching logic with multiple conditions
- **Parameters**: Multiple conditions and outputs
- **Behavior**: Evaluates complex conditional logic and routes execution
- **Use Cases**: Complex decision trees, multi-factor analysis, adaptive experiments

## Loop Control

### ForLoopStep
- **File**: [ForLoopStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/ForLoopStep.cs)
- **NodeTint**: `#3A1078` (Purple)
- **Menu Path**: "Loops/For loop"
- **Purpose**: Fixed iteration loops
- **Parameters**:
  - `iterations` (int): Number of iterations to perform
- **Outputs**:
  - `continueLoop`: Loop body execution path
  - `exit`: Loop completion path
- **Behavior**: Executes loop body specified number of times, then exits
- **Use Cases**: Repeated measurements, systematic testing, data collection

### WhileLoopStep
- **File**: [WhileLoopStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/WhileLoopStep.cs)
- **Purpose**: Conditional loops that continue while condition is true
- **Parameters**:
  - `condition` (NodeObject): Boolean loop condition
- **Outputs**:
  - `continueLoop`: Loop body execution path
  - `exit`: Loop completion path
- **Behavior**: Executes loop body while condition remains true
- **Use Cases**: Convergence testing, adaptive procedures, error recovery

## Common Patterns

### Conditional Execution Pattern
```csharp
// IfStatementStep evaluates boolean input
if (_portValue)
    XnodeStepsRunner.Instance.StepIsDone("True");
else
    XnodeStepsRunner.Instance.StepIsDone("False");
```

### Loop Control Pattern
```csharp
// ForLoopStep manages iteration count
if (_counter < iterations)
{
    _counter++;
    XnodeStepsRunner.Instance.StepIsDone("continueLoop");
}
else
{
    _counter = 0;
    XnodeStepsRunner.Instance.StepIsDone();
}
```

### Sequential Execution Pattern
```csharp
// FirstThenStep executes branches in sequence
// First branch executes completely, then second branch
```

## Experiment Design Patterns

### Educational Experiment Pattern
```
Typical educational flow:
1. IfStatementStep - Check if user is ready
   ├─ True: Proceed to experiment
   └─ False: Show preparation hint
2. ForLoopStep - Repeat measurement procedure
   ├─ continueLoop: Perform measurement
   └─ exit: Analyze results
3. SwitchStep - Route based on results
   ├─ Case 1: Show success message
   ├─ Case 2: Show improvement hints
   └─ Case 3: Show error correction
```

### Research Experiment Pattern
```
Complex research workflow:
1. WhileLoopStep - Adaptive parameter adjustment
   ├─ continueLoop: Adjust and measure
   └─ exit: Convergence achieved
2. SwitchEnumStep - Route by experiment phase
   ├─ Phase.Calibration: Calibration procedure
   ├─ Phase.Measurement: Data collection
   └─ Phase.Analysis: Results processing
3. BranchingControlStep - Multi-factor decision
   ├─ Condition 1: Path A
   ├─ Condition 2: Path B
   └─ Default: Error handling
```

### Error Recovery Pattern
```
Robust error handling:
1. IfStatementStep - Check for errors
   ├─ True: Error recovery path
   └─ False: Normal execution
2. WhileLoopStep - Retry mechanism
   ├─ continueLoop: Retry operation
   └─ exit: Success or max retries
3. SwitchStep - Error type routing
   ├─ ErrorType.Timeout: Retry with delay
   ├─ ErrorType.InvalidInput: Show correction
   └─ ErrorType.System: Abort experiment
```

## Best Practices

1. **Clear Conditions**: Use descriptive boolean inputs for conditional nodes
2. **Loop Limits**: Always set reasonable iteration limits for loops
3. **Error Handling**: Implement error recovery paths in complex branching
4. **Documentation**: Document complex branching logic with comments
5. **Testing**: Test all execution paths in control flow nodes
6. **Modularity**: Use SubGraphStep to encapsulate complex control flow

### Multiple Route Completion Pattern

When you have multiple routes that must all be completed without a specific order:

**Use CompositeStep for parallel route management:**

```
Pattern: Multiple independent routes → CompositeStep → Continue
```

**Implementation:**
1. **Create separate routes** for each independent task
2. **Use CompositeStep** to wait for all routes to complete
3. **Connect each route end** back to the CompositeStep entry
4. **Continue execution** only after all routes are finished

**Correct Connection Pattern:**
```
Start → CompositeStep entry
CompositeStep routes → Route A → Logic → CompositeStep entry
CompositeStep routes → Route B → Logic → CompositeStep entry  
CompositeStep routes → Route C → Logic → CompositeStep entry
CompositeStep exit → Continue to next phase
```

**Actual Implementation (from NewStepsGraph.asset):**
```
DelayStep → CompositeStep entry
CompositeStep routes → ClickStep (Test1) → GameObjectSetActiveStep → CompositeStep entry
CompositeStep routes → ClickStep (Test2) → GameObjectSetActiveStep → CompositeStep entry
CompositeStep routes → ClickStep (Test3) → GameObjectSetActiveStep → CompositeStep entry
CompositeStep exit → SideMessageStep (completion)
```

**Key Connection Details:**
- **DelayStep exit** connects to **CompositeStep entry** (activation)
- **CompositeStep routes** connects to **each ClickStep entry** (route distribution)
- **Each ClickStep exit** connects to **logic step** (e.g., GameObjectSetActiveStep)
- **Logic step exit** connects back to **CompositeStep entry** (route completion)
- **CompositeStep exit** connects to **next step** (completion)

**When to Use:**
- Multiple user interactions that can happen in any order
- Parallel data collection from different sources
- Independent setup procedures that must all complete
- Multi-object interactions where order doesn't matter

**Benefits:**
- Ensures all required actions are completed
- Allows flexible user interaction order
- Maintains clear execution flow
- Prevents premature progression

**Real-World Example:**
```
TestingExperimentGraph Pattern:
1. DelayStep → CompositeStep entry
2. CompositeStep routes → ClickStep (Test1) → GameObjectSetActiveStep → CompositeStep entry
3. CompositeStep routes → ClickStep (Test2) → GameObjectSetActiveStep → CompositeStep entry
4. CompositeStep routes → ClickStep (Test3) → GameObjectSetActiveStep → CompositeStep entry
5. CompositeStep exit → SideMessageStep
```

## Integration with Other Nodes

### With Action-Executed Steps
- Use IfStatementStep to check user input validity
- Use SwitchStep to route based on user actions
- Use WhileLoopStep for retry mechanisms

### With Self-Executed Steps
- Use FunctionCallStep to evaluate conditions
- Use DelayStep in loop bodies for timing
- Use HintStep to provide guidance in branches

### With Variable Nodes
- Pass boolean values to conditional nodes
- Use loop counters for iteration control
- Store decision results for later use

## Performance Considerations

1. **Loop Efficiency**: Avoid infinite loops by setting proper exit conditions
2. **Condition Evaluation**: Keep condition evaluation lightweight
3. **Branch Complexity**: Limit the number of branches in complex nodes
4. **Memory Management**: Clean up resources in loop bodies

## Debugging Tips

1. **Logging**: Add debug logs to track execution paths
2. **Visualization**: Use node tinting to identify control flow nodes
3. **Step-by-Step**: Test each branch individually
4. **Condition Testing**: Verify boolean inputs are correct

## File References

- Control flow directory: [Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/)
- Loop directory: [Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/)
- Base step class: [SelfExectutedStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExectutedStep.cs)
This pattern prioritizes educational value over complex control flow,
using simple sequential execution with user-paced progression.
```

# Control Flow Step Nodes

Control flow step nodes manage the execution logic and branching in experiment workflows. These nodes inherit from `SelfExectutedStep` and provide conditional execution, loops, and complex branching patterns.

## Location
**Directory**: `Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/`

## Conditional Branching

### IfStatementStep
- **File**: [IfStatementStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/IfStatementStep.cs)
- **NodeTint**: `#643843` (Dark Purple)
- **Menu Path**: "Control Flow/If Statement Step"
- **Purpose**: Simple conditional branching based on boolean input
- **Parameters**:
  - `entry` (NodeObject): Boolean input condition
- **Outputs**:
  - `True`: Execution path when condition is true
  - `False`: Execution path when condition is false
- **Behavior**: Evaluates boolean input and routes execution accordingly
- **Use Cases**: Simple yes/no decisions, error checking, condition validation

### SwitchStep
- **File**: [SwitchStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/SwitchStep.cs)
- **Purpose**: Multi-way branching based on input value
- **Parameters**:
  - `entry` (NodeObject): Switch value to evaluate
- **Outputs**: Multiple output ports for different cases
- **Behavior**: Routes execution based on input value matching specific cases
- **Use Cases**: State machines, menu systems, multi-option decisions

### SwitchEnumStep
- **File**: [SwitchEnumStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/SwitchEnumStep.cs)
- **Purpose**: Enum-based switching for type-safe branching
- **Parameters**:
  - `entry` (NodeObject): Enum value to evaluate
- **Outputs**: Output ports corresponding to enum values
- **Behavior**: Routes execution based on enum value
- **Use Cases**: Experiment phases, measurement types, material states

## Sequential Execution

### FirstThenStep
- **File**: [FirstThenStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/FirstThenStep.cs)
- **Purpose**: Execute first branch, then second branch sequentially
- **Outputs**:
  - `first`: First execution path
  - `then`: Second execution path (executes after first completes)
- **Behavior**: Executes first path completely, then second path
- **Use Cases**: Setup then measurement, calibration then testing, preparation then execution

### CompositeStep
- **File**: [CompositeStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/CompositeStep.cs)
- **Purpose**: Combine multiple steps into a single execution unit
- **Parameters**: Multiple input steps
- **Behavior**: Executes multiple steps in sequence as a single unit
- **Use Cases**: Complex procedures, multi-step operations, grouped actions

## Complex Branching

### BranchingControlStep
- **File**: [BranchingControlStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/BranchingControlStep.cs)
- **Purpose**: Advanced branching logic with multiple conditions
- **Parameters**: Multiple conditions and outputs
- **Behavior**: Evaluates complex conditional logic and routes execution
- **Use Cases**: Complex decision trees, multi-factor analysis, adaptive experiments

## Loop Control

### ForLoopStep
- **File**: [ForLoopStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/ForLoopStep.cs)
- **NodeTint**: `#3A1078` (Purple)
- **Menu Path**: "Loops/For loop"
- **Purpose**: Fixed iteration loops
- **Parameters**:
  - `iterations` (int): Number of iterations to perform
- **Outputs**:
  - `continueLoop`: Loop body execution path
  - `exit`: Loop completion path
- **Behavior**: Executes loop body specified number of times, then exits
- **Use Cases**: Repeated measurements, systematic testing, data collection

### WhileLoopStep
- **File**: [WhileLoopStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/WhileLoopStep.cs)
- **Purpose**: Conditional loops that continue while condition is true
- **Parameters**:
  - `condition` (NodeObject): Boolean loop condition
- **Outputs**:
  - `continueLoop`: Loop body execution path
  - `exit`: Loop completion path
- **Behavior**: Executes loop body while condition remains true
- **Use Cases**: Convergence testing, adaptive procedures, error recovery

## Common Patterns

### Conditional Execution Pattern
```csharp
// IfStatementStep evaluates boolean input
if (_portValue)
    XnodeStepsRunner.Instance.StepIsDone("True");
else
    XnodeStepsRunner.Instance.StepIsDone("False");
```

### Loop Control Pattern
```csharp
// ForLoopStep manages iteration count
if (_counter < iterations)
{
    _counter++;
    XnodeStepsRunner.Instance.StepIsDone("continueLoop");
}
else
{
    _counter = 0;
    XnodeStepsRunner.Instance.StepIsDone();
}
```

### Sequential Execution Pattern
```csharp
// FirstThenStep executes branches in sequence
// First branch executes completely, then second branch
```

## Experiment Design Patterns

### Educational Experiment Pattern
```
Typical educational flow:
1. IfStatementStep - Check if user is ready
   ├─ True: Proceed to experiment
   └─ False: Show preparation hint
2. ForLoopStep - Repeat measurement procedure
   ├─ continueLoop: Perform measurement
   └─ exit: Analyze results
3. SwitchStep - Route based on results
   ├─ Case 1: Show success message
   ├─ Case 2: Show improvement hints
   └─ Case 3: Show error correction
```

### Research Experiment Pattern
```
Complex research workflow:
1. WhileLoopStep - Adaptive parameter adjustment
   ├─ continueLoop: Adjust and measure
   └─ exit: Convergence achieved
2. SwitchEnumStep - Route by experiment phase
   ├─ Phase.Calibration: Calibration procedure
   ├─ Phase.Measurement: Data collection
   └─ Phase.Analysis: Results processing
3. BranchingControlStep - Multi-factor decision
   ├─ Condition 1: Path A
   ├─ Condition 2: Path B
   └─ Default: Error handling
```

### Error Recovery Pattern
```
Robust error handling:
1. IfStatementStep - Check for errors
   ├─ True: Error recovery path
   └─ False: Normal execution
2. WhileLoopStep - Retry mechanism
   ├─ continueLoop: Retry operation
   └─ exit: Success or max retries
3. SwitchStep - Error type routing
   ├─ ErrorType.Timeout: Retry with delay
   ├─ ErrorType.InvalidInput: Show correction
   └─ ErrorType.System: Abort experiment
```

## Best Practices

1. **Clear Conditions**: Use descriptive boolean inputs for conditional nodes
2. **Loop Limits**: Always set reasonable iteration limits for loops
3. **Error Handling**: Implement error recovery paths in complex branching
4. **Documentation**: Document complex branching logic with comments
5. **Testing**: Test all execution paths in control flow nodes
6. **Modularity**: Use SubGraphStep to encapsulate complex control flow

### Multiple Route Completion Pattern

When you have multiple routes that must all be completed without a specific order:

**Use CompositeStep for parallel route management:**

```
Pattern: Multiple independent routes → CompositeStep → Continue
```

**Implementation:**
1. **Create separate routes** for each independent task
2. **Use CompositeStep** to wait for all routes to complete
3. **Connect each route end** back to the CompositeStep entry
4. **Continue execution** only after all routes are finished

**Correct Connection Pattern:**
```
Start → CompositeStep entry
CompositeStep routes → Route A → Logic → CompositeStep entry
CompositeStep routes → Route B → Logic → CompositeStep entry  
CompositeStep routes → Route C → Logic → CompositeStep entry
CompositeStep exit → Continue to next phase
```

**Actual Implementation (from NewStepsGraph.asset):**
```
DelayStep → CompositeStep entry
CompositeStep routes → ClickStep (Test1) → GameObjectSetActiveStep → CompositeStep entry
CompositeStep routes → ClickStep (Test2) → GameObjectSetActiveStep → CompositeStep entry
CompositeStep routes → ClickStep (Test3) → GameObjectSetActiveStep → CompositeStep entry
CompositeStep exit → SideMessageStep (completion)
```

**Key Connection Details:**
- **DelayStep exit** connects to **CompositeStep entry** (activation)
- **CompositeStep routes** connects to **each ClickStep entry** (route distribution)
- **Each ClickStep exit** connects to **logic step** (e.g., GameObjectSetActiveStep)
- **Logic step exit** connects back to **CompositeStep entry** (route completion)
- **CompositeStep exit** connects to **next step** (completion)

**When to Use:**
- Multiple user interactions that can happen in any order
- Parallel data collection from different sources
- Independent setup procedures that must all complete
- Multi-object interactions where order doesn't matter

**Benefits:**
- Ensures all required actions are completed
- Allows flexible user interaction order
- Maintains clear execution flow
- Prevents premature progression

**Real-World Example:**
```
TestingExperimentGraph Pattern:
1. DelayStep → CompositeStep entry
2. CompositeStep routes → ClickStep (Test1) → GameObjectSetActiveStep → CompositeStep entry
3. CompositeStep routes → ClickStep (Test2) → GameObjectSetActiveStep → CompositeStep entry
4. CompositeStep routes → ClickStep (Test3) → GameObjectSetActiveStep → CompositeStep entry
5. CompositeStep exit → SideMessageStep
```

## Integration with Other Nodes

### With Action-Executed Steps
- Use IfStatementStep to check user input validity
- Use SwitchStep to route based on user actions
- Use WhileLoopStep for retry mechanisms

### With Self-Executed Steps
- Use FunctionCallStep to evaluate conditions
- Use DelayStep in loop bodies for timing
- Use HintStep to provide guidance in branches

### With Variable Nodes
- Pass boolean values to conditional nodes
- Use loop counters for iteration control
- Store decision results for later use

## Performance Considerations

1. **Loop Efficiency**: Avoid infinite loops by setting proper exit conditions
2. **Condition Evaluation**: Keep condition evaluation lightweight
3. **Branch Complexity**: Limit the number of branches in complex nodes
4. **Memory Management**: Clean up resources in loop bodies

## Debugging Tips

1. **Logging**: Add debug logs to track execution paths
2. **Visualization**: Use node tinting to identify control flow nodes
3. **Step-by-Step**: Test each branch individually
4. **Condition Testing**: Verify boolean inputs are correct

## File References

- Control flow directory: [Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/ControlFlow/)
- Loop directory: [Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/](mdc:Assets/Scripts/System/xNode/Steps/SelfExecuted/Loops/)
- Base step class: [SelfExectutedStep.cs](mdc:Assets/Scripts/System/xNode/Steps/SelfExectutedStep.cs)
This pattern prioritizes educational value over complex control flow,
using simple sequential execution with user-paced progression.
```